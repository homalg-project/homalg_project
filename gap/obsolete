##
## from change.log:
##
- added way to optionally ignore the logical subpackages
  (LRING, LIMAT, COLEM, LIMOD) by setting the global variable
  DoNotLoadLogicForHomalg to true (a warning will be issued)

##
## from read.g
##

## LogicForHomalg subpackages
if not ( IsBound( DoNotLoadLogicForHomalg ) and DoNotLoadLogicForHomalg = true ) then
    ReadPackage( "homalg", "gap/LIRNG.gi" );
    ReadPackage( "homalg", "gap/LIMAT.gi" );
    ReadPackage( "homalg", "gap/COLEM.gi" );
    ReadPackage( "homalg", "gap/LIMOD.gi" );
else
    Print( "WARNING: the subpackage LogicForHomalg was not loaded!\n" );
fi;



##
## from: HomalgGenerators.gi
##

##
InstallMethod( BasisOfModule,
        "for sets of generators of homalg modules",
        [ IsGeneratorsOfFinitelyGeneratedModuleRep and IsHomalgGeneratorsOfLeftModule ],
        
  function( gen )
    local bas;
    
    if not IsBound( gen!.BasisOfModule ) then
        gen!.BasisOfModule := BasisOfRows( MatrixOfGenerators( gen ) );
        SetCanBeUsedToDecideZeroEffectively( gen, false );
    fi;
    
    bas := HomalgGeneratorsForLeftModule( gen!.BasisOfModule, HomalgRing( gen ) );
    
    SetCanBeUsedToDecideZeroEffectively( bas, true );
    
    return HomalgRelationsForLeftModule( MatrixOfGenerators( bas ) );	## FIXME: written for \/ in Modules.gi (should become obsolete when DefectOfExactness arrives)
    
end );

##
InstallMethod( BasisOfModule,
        "for sets of generators of homalg modules",
        [ IsGeneratorsOfFinitelyGeneratedModuleRep and IsHomalgGeneratorsOfRightModule ],
        
  function( gen )
    local bas;
    
    if not IsBound( gen!.BasisOfModule ) then
        gen!.BasisOfModule := BasisOfColumns( MatrixOfGenerators( gen ) );
        SetCanBeUsedToDecideZeroEffectively( gen, false );
    fi;
    
    bas := HomalgGeneratorsForRightModule( gen!.BasisOfModule, HomalgRing( gen ) );
    
    SetCanBeUsedToDecideZeroEffectively( bas, true );
        
    return HomalgRelationsForRightModule( MatrixOfGenerators( bas ) );	## FIXME: written for \/ in Modules.gi (should become obsolete when DefectOfExactness arrives)
    
end );

##
## from: Modules.gi
##

##
InstallMethod( \/,				### defines: SubfactorModule (incomplete)
        "for homalg generators",
        [ IsGeneratorsOfFinitelyGeneratedModuleRep, IsGeneratorsOfFinitelyGeneratedModuleRep ],
        
  function( gen1, gen2 )
    local R, B, N, S;
    
    R := HomalgRing( gen1 );
    
    # basis of gen2
    B := BasisOfModule( gen2 );
    
    # normal forms of generators of gen1 with respect to B
    N := DecideZero( gen1, B );
    
    if IsHomalgGeneratorsOfLeftModule( gen1 ) then
        N := HomalgGeneratorsForLeftModule( N );
    else
        N := HomalgGeneratorsForRightModule( N );
    fi;
    
    # get a better basis for N
    N := GetRidOfObsoleteGenerators( N );
    
    # compute the syzygies module of N modulo B
    S := SyzygiesGenerators( N, B );
    
    return Presentation( S );
    
end );

## was part of _Functor_Cokernel_OnObjects

    if IsZero( phi ) then
        coker := Range( phi );
        epi := TheIdentityMorphism( coker );
        if not IsBound( coker!.NaturalGeneralizedEmbedding ) then
            coker!.NaturalGeneralizedEmbedding := epi;
        fi;
        SetCokernelEpi( phi, epi );
        return coker;	## this is crucial for IsIdenticalObj( Ext( 0, M, N ), Hom( M, N ) ) = true (we hope there is no need to set further attributes as below)
    fi;
    
## from HomalgComplex
##
InstallMethod( ViewObj,
        "for homalg complexes",
        [ IsComplexOfFinitelyPresentedObjectsRep and IsAcyclic ],
        
  function( o )
    local l, degrees;
    
    Print( "<An acyclic complex consisting of " );
    
    degrees := ObjectDegreesOfComplex( o );
    
    l := Length( degrees );
    
    if l = 1 then
        Print( "a single" );
    else
        Print( l );
    fi;
    
    if IsHomalgLeftObjectOrMorphismOfLeftObjects( o ) then
        Print( " left" );
    else
        Print( " right" );
    fi;
    
    if IsHomalgModule( CertainObject( o, degrees[1] ) ) then
        Print( " module" );
        if l > 1 then
            Print( "s" );
        fi;
    else
        if IsComplexOfFinitelyPresentedObjectsRep( CertainObject( o, degrees[1] ) ) then
            Print( " complex" );
        else
            Print( " cocomplex" );
        fi;
        if l > 1 then
            Print( "es" );
        fi;
    fi;
    
    Print( " at degree" );
    
    if l = 1 then
        Print( " ", degrees[1] );
    else
        Print( "s ", degrees );
    fi;
    
    Print( ">" );
    
end );

##
InstallMethod( ViewObj,
        "for homalg complexes",
        [ IsCocomplexOfFinitelyPresentedObjectsRep and IsAcyclic ],
        
  function( o )
    local l, degrees;
    
    Print( "<An acyclic cocomplex consisting of " );
    
    degrees := ObjectDegreesOfComplex( o );
    
    l := Length( degrees );
    
    if l = 1 then
        Print( "a single" );
    else
        Print( l );
    fi;
    
    if IsHomalgLeftObjectOrMorphismOfLeftObjects( o ) then
        Print( " left" );
    else
        Print( " right" );
    fi;
    
    if IsHomalgModule( CertainObject( o, degrees[1] ) ) then
        Print( " module" );
        if l > 1 then
            Print( "s" );
        fi;
    else
        if IsComplexOfFinitelyPresentedObjectsRep( CertainObject( o, degrees[1] ) ) then
            Print( " complex" );
        else
            Print( " cocomplex" );
        fi;
        if l > 1 then
            Print( "es" );
        fi;
    fi;
    
    Print( " at cohomology degree" );
    
    if l = 1 then
        Print( " ", degrees[1] );
    else
        Print( "s ", degrees );
    fi;
    
    Print( ">" );
    
end );

## from HomalgMatrix

    internal := false;
    
    if IsMatrix( M ) then
        internal := true;
    elif IsList( M ) and ForAll( M, a -> a = [ ] ) then	## this must remain above the next ifs
        internal := true;
    elif IsBound( HOMALG.OtherInternalMatrixTypes ) then
        for ar in HOMALG.OtherInternalMatrixTypes do
            internal := internal or ar( M );
            if internal then
                break;
            fi;
        od;
    fi;
    
## from BasicFunctors.gi

## install Cokernel for image squares (this should be installed automatically in the future)
InstallOtherMethod( Cokernel,
        "for homalg image squares",
        [ IsHomalgChainMap and IsImageSquare ],
  function( sq )
    local d, dS, dT, phi, muS, muT;
    
    d := DegreesOfChainMap( sq )[1];
    
    dS := LowestDegreeMorphism( Source( sq ) );
    dT := LowestDegreeMorphism( Range( sq ) );
    
    phi := CertainMorphism( sq, d );
    
    muS := NaturalGeneralizedEmbedding( Cokernel( dS ) );
    muT := NaturalGeneralizedEmbedding( Cokernel( dT ) );
    
    return CompleteImageSquare( muS, phi, muT );
    
end );

## install Kernel for kernel squares (this should be installed automatically in the future)
InstallOtherMethod( Kernel,
        "for homalg kernel squares",
        [ IsHomalgChainMap and IsKernelSquare ],
  function( sq )
    local d, dS, dT, phi, muS, muT;
    
    d := DegreesOfChainMap( sq )[1];
    
    dS := LowestDegreeMorphism( Source( sq ) );
    dT := LowestDegreeMorphism( Range( sq ) );
    
    phi := CertainMorphism( sq, d );
    
    muS := NaturalGeneralizedEmbedding( Kernel( dS ) );
    muT := NaturalGeneralizedEmbedding( Kernel( dT ) );
    
    return CompleteImageSquare( muS, phi, muT );
    
end );

## install DefectOfExactness for Lambek pair of squares (this should be installed automatically in the future)
InstallOtherMethod( DefectOfExactness,
        "for homalg Lambek pair of squares",
        [ IsHomalgChainMap and IsLambekPairOfSquares ],
  function( sq )
    local d, dS, dT, phi, muS, muT;
    
    d := DegreesOfChainMap( sq )[1];
    
    dS := AsATwoSequence( Source( sq ) );
    dT := AsATwoSequence( Range( sq ) );
    
    phi := CertainMorphism( sq, d );
    
    muS := NaturalGeneralizedEmbedding( DefectOfExactness( dS ) );
    muT := NaturalGeneralizedEmbedding( DefectOfExactness( dT ) );
    
    return CompleteImageSquare( muS, phi, muT );
    
end );

## install KernelEmb for kernel squares (this should be installed automatically in the future)
InstallOtherMethod( KernelEmb,
        "for homalg kernel squares",
        [ IsHomalgChainMap and IsKernelSquare ],
  function( sq )
    local d, dS, dT, phi, muS, muT, kappa;
    
    d := DegreesOfChainMap( sq )[1];
    
    dS := LowestDegreeMorphism( Source( sq ) );
    dT := LowestDegreeMorphism( Range( sq ) );
    
    phi := CertainMorphism( sq, d );
    
    muS := KernelEmb( dS );
    muT := KernelEmb( dT );
    
    kappa := CompleteImageSquare( muS, phi, muT );
    
    if IsComplexOfFinitelyPresentedObjectsRep( Source( sq ) ) then
        muS := HomalgComplex( muS, d + 1 );
        muT := HomalgComplex( muT, d + 1 );
        kappa := HomalgChainMap( kappa, muS, muT, d + 1 );
    else
        muS := HomalgCocomplex( muS, d - 1 );
        muT := HomalgCocomplex( muT, d - 1 );
        kappa := HomalgChainMap( kappa, muS, muT, d - 1 );
    fi;
    
    return kappa;
    
end );

## from LIMOD
##
InstallImmediateMethod( ElementaryDivisorsOfLeftModule,
        IsFinitelyPresentedModuleRep and IsZeroModule and HasLeftActingDomain, 0, ## FIXME: remove HasLeftActingDomain
        
  function( M )
    local R;
    
    R := HomalgRing( M );
    
    if HasIsLeftPrincipalIdealRing( R ) and IsLeftPrincipalIdealRing( R ) then
        return [ ];
    fi;
    
    TryNextMethod( );
    
end );

##
InstallImmediateMethod( ElementaryDivisorsOfLeftModule,
        IsFinitelyPresentedModuleRep and IsFreeModule and HasLeftActingDomain, 0, ## FIXME: remove HasLeftActingDomain
        
  function( M )
    local R;
    
    R := HomalgRing( M );
    
    if HasIsLeftPrincipalIdealRing( R ) and IsLeftPrincipalIdealRing( R ) then
        return ListWithIdenticalEntries( NrGenerators( M ), Zero( R ) );
    fi;
    
    TryNextMethod( );
    
end );

## from HomalgMap
##
InstallMethod( \*,
        "of two homalg maps",
        [ IsRingElement, IsMapOfFinitelyGeneratedModulesRep ], 1001, ## it could otherwise run into the method ``PROD: negative integer * additive element with inverse'', value: 24
        
  function( a, phi )
    local a_phi;
    
    a_phi := HomalgMap( a * MatrixOfMap( phi ), Source( phi ), Range( phi ) );
    
    if IsUnit( HomalgRing( phi ), a ) then
        if HasIsIsomorphism( phi ) and IsIsomorphism( phi ) then
            SetIsIsomorphism( a_phi, true );
        else
            if HasIsSplitMonomorphism( phi ) and IsSplitMonomorphism( phi ) then
                SetIsSplitMonomorphism( a_phi, true );
            elif HasIsMonomorphism( phi ) and IsMonomorphism( phi ) then
                SetIsMonomorphism( a_phi, true );
            fi;
            
            if HasIsSplitEpimorphism( phi ) and IsSplitEpimorphism( phi ) then
                SetIsSplitEpimorphism( a_phi, true );
            elif HasIsEpimorphism( phi ) and IsEpimorphism( phi ) then
                SetIsEpimorphism( a_phi, true );
            elif HasIsMorphism( phi ) and IsMorphism( phi ) then
                SetIsMorphism( a_phi, true );
            fi;
        fi;
    elif HasIsMorphism( phi ) and IsMorphism( phi ) then
        SetIsMorphism( a_phi, true );
    fi;
    
    return a_phi;
    
end );

##
InstallMethod( \+,
        "of two homalg maps",
        [ IsMapOfFinitelyGeneratedModulesRep, IsMapOfFinitelyGeneratedModulesRep ],
        
  function( phi1, phi2 )
    local phi;
    
    if not AreComparableMorphisms( phi1, phi2 ) then
        return Error( "the two maps are not comparable" );
    fi;
    
    phi := HomalgMap( MatrixOfMap( phi1 ) + MatrixOfMap( phi2 ), Source( phi1 ), Range( phi1 ) );
    
    if HasIsMorphism( phi1 ) and IsMorphism( phi1 ) and
       HasIsMorphism( phi2 ) and IsMorphism( phi2 ) then
        SetIsMorphism( phi, true );
    fi;
    
    return phi;
    
end );

##
InstallMethod( \-,
        "of two homalg maps",
        [ IsMapOfFinitelyGeneratedModulesRep, IsMapOfFinitelyGeneratedModulesRep ],
        
  function( phi1, phi2 )
    local phi;
    
    if not AreComparableMorphisms( phi1, phi2 ) then
        return Error( "the two maps are not comparable" );
    fi;
    
    phi := HomalgMap( MatrixOfMap( phi1 ) - MatrixOfMap( phi2 ), Source( phi1 ), Range( phi1 ) );
    
    if HasIsMorphism( phi1 ) and IsMorphism( phi1 ) and
       HasIsMorphism( phi2 ) and IsMorphism( phi2 ) then
        SetIsMorphism( phi, true );
    fi;
    
    return phi;
    
end );

## from change log
- the attribute Eval of an internal homalg matrix is now not directly
  a gap matrix (i.e. IsMatrix) but a hull of it:
  this allows changing their entries!!!
  for this the following was added:
  . a GAP-category IsInternalMatrixHull
  . a simple constructor called homalgInternalMatrixHull
  . a method for \=
  . a method for scalar multiplication \*
  . a method for addition \+
  . a method for AdditiveInverseMutable
  . a method for substraction \-
  . a method for composition \*
  . a simple view method
  . a display method that simply displays the contained matrix
- adapted the code to use Eval( M )!.matrix instead of Eval( M )
  and to return homalgInternalMatrixHull( IsMatrix )
- added the matrix "property" IsMutableMatrix which is only set to true for
  IsInitialMatrix and IsInitialIdentityMatrix (otherwise not set)
  (programmers should reset it when they finished changing the matrix)
- declared and installed SetEntryOfHomalgMatrix for internal matrices
  together with methods that issue the following error if the property
  IsMutableMatrix is not set (to true):
  Error( "the homalg matrix is write-protected\n" );
- declared and installed AddToEntryOfHomalgMatrix together with a method
  that issues the "write-protected"-error if the matrix is not set
  IsMutableMatrix (to true)
- GetEntryOfHomalgMatrixAsString is now based on GetEntryOfHomalgMatrix
- if the input of HomalgMatrix is an IsMatrix a shallow copy of it is made
- HomalgMatrix now additionally accepts a hull of an internal matrix as its
  first argument
- fixed loading GaussForHomalg in HomalgFieldOfRationals
- fixed evaluating internal initial (zero) matrices
- use ObjectifyWithAttributes more consequently in
  . HomalgMatrix
  . HomalgZeroMatrix
  . HomalgIdentityMatrix
  . HomalgInitialMatrix
  . HomalgInitialIdentityMatrix
  . HomalgVoidMatrix
## from HomalgMatrix.gi/gd

DeclareOperation( "AddToEntryOfHomalgMatrix",
        [ IsHomalgMatrix, IsInt, IsInt, IsString, IsHomalgRing ] );

DeclareOperation( "AddToEntryOfHomalgMatrix",
        [ IsHomalgMatrix, IsInt, IsInt, IsString ] );


##
InstallMethod( AddToEntryOfHomalgMatrix,
        "for homalg matrices",
        [ IsHomalgMatrix and IsMutableMatrix, IsInt, IsInt, IsString, IsHomalgInternalRingRep ],
        
  function( M, r, c, s, R )
    
    AddToEntryOfHomalgMatrix( M, r, c, One( R ) * EvalString( s ), R );
    
end );

##
InstallMethod( AddToEntryOfHomalgMatrix,
        "for homalg matrices",
        [ IsHomalgMatrix, IsInt, IsInt, IsString ],
        
  function( M, r, c, s )
    
    Error( "the homalg matrix is write-protected\n" );
    
end );

##
InstallMethod( AddToEntryOfHomalgMatrix,
        "for homalg matrices",
        [ IsHomalgMatrix and IsMutableMatrix, IsInt, IsInt, IsString ],
        
  function( M, r, c, s )
    
    AddToEntryOfHomalgMatrix( M, r, c, s, HomalgRing( M ) );
    
end );

## from HomalgBicomplex.gi

##
DeclareOperation( "ObjectOfTotalComplex",
        [ IsHomalgBicomplex, IsInt ] );

##
InstallMethod( ObjectOfTotalComplex,
        "for homalg bicomplexes",
        [ IsHomalgBicomplex, IsInt ],
        
  function( B, n )
    local bidegrees, tot_n, pq, sum, l, summand, embeddings, i, emb_summand;
    
    bidegrees := BidegreesOfObjectOfTotalComplex( B, n );
    
    if bidegrees = [ ] then
        return fail;
    fi;
    
    tot_n := [ ];
    
    for pq in bidegrees do
        Add( tot_n, CertainObject( B, pq ) );
    od;
    
    sum := Sum( tot_n );
    
    l := Length( tot_n );
    
    if l > 1 then
        summand := sum;
        embeddings := rec( );
        embeddings.(String(bidegrees[l])) := DirectSumEmbs( summand )[2];
        for i in [ 1 .. l - 1 ] do
            emb_summand := DirectSumEmbs( summand )[2];
            summand := Genesis( summand )!.arguments_of_functor[1];
            embeddings.(String(bidegrees[l - i])) := PreCompose( DirectSumEmbs( summand )[2], emb_summand );
        od;
        sum!.EmbeddingsInObjectOfTotalComplex := embeddings;
    fi;
    
    return sum;
    
end );

## from LIMAT.gi

##
InstallTrueMethod( IsReducedModuloRingRelations, IsHomalgMatrix and IsZero );

##
InstallTrueMethod( IsZero, IsHomalgMatrix and IsEmptyMatrix );

##
InstallTrueMethod( IsPermutationMatrix, IsHomalgMatrix and IsIdentityMatrix );

##
InstallTrueMethod( IsPermutationMatrix, IsHomalgMatrix and IsSubidentityMatrix and IsInvertibleMatrix );

##
InstallTrueMethod( IsInvertibleMatrix, IsHomalgMatrix and IsPermutationMatrix );

##
InstallTrueMethod( IsSubidentityMatrix, IsHomalgMatrix and IsPermutationMatrix );

##
InstallTrueMethod( IsSubidentityMatrix, IsHomalgMatrix and IsEmptyMatrix );

##
InstallTrueMethod( IsLeftInvertibleMatrix, IsHomalgMatrix and IsPermutationMatrix );

##
InstallTrueMethod( IsRightInvertibleMatrix, IsHomalgMatrix and IsPermutationMatrix );

## a split injective morphism (of free modules) is injective
InstallTrueMethod( IsLeftRegularMatrix, IsHomalgMatrix and IsRightInvertibleMatrix );

##
InstallTrueMethod( IsRightRegularMatrix, IsHomalgMatrix and IsLeftInvertibleMatrix );

## an isomorphism is split injective
InstallTrueMethod( IsRightInvertibleMatrix, IsHomalgMatrix and IsInvertibleMatrix );

## an isomorphism is split surjective
InstallTrueMethod( IsLeftInvertibleMatrix, IsHomalgMatrix and IsInvertibleMatrix );

## a split surjective and split injective morphism (of free modules) is an isomorphism
InstallTrueMethod( IsInvertibleMatrix, IsHomalgMatrix and IsLeftInvertibleMatrix and IsRightInvertibleMatrix );

##
InstallTrueMethod( IsUpperTriangularMatrix, IsHomalgMatrix and IsDiagonalMatrix );

##
InstallTrueMethod( IsLowerTriangularMatrix, IsHomalgMatrix and IsDiagonalMatrix );

##
InstallTrueMethod( IsUpperTriangularMatrix, IsHomalgMatrix and IsStrictUpperTriangularMatrix );

##
InstallTrueMethod( IsLowerTriangularMatrix, IsHomalgMatrix and IsStrictLowerTriangularMatrix );

##
InstallTrueMethod( IsUpperTriangularMatrix, IsHomalgMatrix and IsUpperStairCaseMatrix );

##
InstallTrueMethod( IsLowerTriangularMatrix, IsHomalgMatrix and IsLowerStairCaseMatrix );

##
InstallTrueMethod( IsTriangularMatrix, IsHomalgMatrix and IsUpperTriangularMatrix );

##
InstallTrueMethod( IsTriangularMatrix, IsHomalgMatrix and IsLowerTriangularMatrix );

##
InstallTrueMethod( IsDiagonalMatrix, IsHomalgMatrix and IsUpperTriangularMatrix and IsLowerTriangularMatrix );

##
InstallTrueMethod( IsDiagonalMatrix, IsHomalgMatrix and IsZero );

##
InstallTrueMethod( IsStrictUpperTriangularMatrix, IsHomalgMatrix and IsZero );

##
InstallTrueMethod( IsStrictLowerTriangularMatrix, IsHomalgMatrix and IsZero );

##
InstallTrueMethod( IsDiagonalMatrix, IsHomalgMatrix and IsIdentityMatrix );

##
InstallTrueMethod( IsZero, IsHomalgMatrix and IsStrictUpperTriangularMatrix and IsStrictLowerTriangularMatrix );

## from HomalgMap.gi

##
InstallMethod( StackMaps,
        "of two homalg maps",
        [ IsMapOfFinitelyGeneratedModulesRep and IsHomalgLeftObjectOrMorphismOfLeftObjects,
          IsMapOfFinitelyGeneratedModulesRep and IsHomalgLeftObjectOrMorphismOfLeftObjects ],
        
  function( phi, psi )
    local T, phi_psi, SpS, p;
    
    T := Range( phi );
    
    if not IsIdenticalObj( T, Range( psi ) ) then
        Error( "the two morphisms must have identical target modules\n" );
    fi;
    
    phi_psi := UnionOfRows( MatrixOfMap( phi ), MatrixOfMap( psi ) );
    
    SpS := Source( phi ) + Source( psi );
    
    ## get the position of the set of relations immediately after creating SpS;
    p := Genesis( SpS ).("PositionOfTheDefaultSetOfRelationsOfTheOutput");
    
    phi_psi := HomalgMap( phi_psi, [ SpS, p ], T );
    
    if HasIsEpimorphism( phi ) and IsEpimorphism( phi ) and
       HasIsMorphism( psi ) and IsMorphism( psi ) then
        SetIsEpimorphism( phi_psi, true );
    elif HasIsMorphism( phi ) and IsMorphism( phi ) and
       HasIsEpimorphism( psi ) and IsEpimorphism( psi ) then
        SetIsEpimorphism( phi_psi, true );
    elif HasIsMorphism( phi ) and IsMorphism( phi ) and
       HasIsMorphism( psi ) and IsMorphism( psi ) then
        SetIsMorphism( phi_psi, true );
    fi;
    
    return phi_psi;
    
end );

##
InstallMethod( StackMaps,
        "of two homalg maps",
        [ IsMapOfFinitelyGeneratedModulesRep and IsHomalgRightObjectOrMorphismOfRightObjects,
          IsMapOfFinitelyGeneratedModulesRep and IsHomalgRightObjectOrMorphismOfRightObjects ],
        
  function( phi, psi )
    local T, phi_psi, SpS, p;
    
    T := Range( phi );
    
    if not IsIdenticalObj( T, Range( psi ) ) then
        Error( "the two morphisms must have identical target modules\n" );
    fi;
    
    phi_psi := UnionOfColumns( MatrixOfMap( phi ), MatrixOfMap( psi ) );
    
    SpS := Source( phi ) + Source( psi );
    
    ## get the position of the set of relations immediately after creating SpS;
    p := Genesis( SpS ).("PositionOfTheDefaultSetOfRelationsOfTheOutput");
    
    phi_psi := HomalgMap( phi_psi, [ SpS, p ], T );
    
    if HasIsEpimorphism( phi ) and IsEpimorphism( phi ) and
       HasIsMorphism( psi ) and IsMorphism( psi ) then
        SetIsEpimorphism( phi_psi, true );
    elif HasIsMorphism( phi ) and IsMorphism( phi ) and
       HasIsEpimorphism( psi ) and IsEpimorphism( psi ) then
        SetIsEpimorphism( phi_psi, true );
    elif HasIsMorphism( phi ) and IsMorphism( phi ) and
       HasIsMorphism( psi ) and IsMorphism( psi ) then
        SetIsMorphism( phi_psi, true );
    fi;
    
    return phi_psi;
    
end );

##
InstallMethod( AugmentMaps,
        "of two homalg maps",
        [ IsMapOfFinitelyGeneratedModulesRep and IsHomalgLeftObjectOrMorphismOfLeftObjects,
          IsMapOfFinitelyGeneratedModulesRep and IsHomalgLeftObjectOrMorphismOfLeftObjects ],
        
  function( phi, psi )
    local S, phi_psi, TpT, p;
    
    S := Source( phi );
    
    if not IsIdenticalObj( S, Source( psi ) ) then
        Error( "the two morphisms must have identical source modules\n" );
    fi;
    
    phi_psi := UnionOfColumns( MatrixOfMap( phi ), MatrixOfMap( psi ) );
    
    TpT := Range( phi ) + Range( psi );
    
    ## get the position of the set of relations immediately after creating TpT;
    p := Genesis( TpT ).("PositionOfTheDefaultSetOfRelationsOfTheOutput");
    
    phi_psi := HomalgMap( phi_psi, S, [ TpT, p ] );
    
    if HasIsMonomorphism( phi ) and IsMonomorphism( phi ) and
       HasIsMorphism( psi ) and IsMorphism( psi ) then
        SetIsMonomorphism( phi_psi, true );
    elif HasIsMorphism( phi ) and IsMorphism( phi ) and
       HasIsMonomorphism( psi ) and IsMonomorphism( psi ) then
        SetIsMonomorphism( phi_psi, true );
    elif HasIsMorphism( phi ) and IsMorphism( phi ) and
       HasIsMorphism( psi ) and IsMorphism( psi ) then
        SetIsMorphism( phi_psi, true );
    fi;
    
    return phi_psi;
    
end );

##
InstallMethod( AugmentMaps,
        "of two homalg maps",
        [ IsMapOfFinitelyGeneratedModulesRep and IsHomalgRightObjectOrMorphismOfRightObjects,
          IsMapOfFinitelyGeneratedModulesRep and IsHomalgRightObjectOrMorphismOfRightObjects ],
        
  function( phi, psi )
    local S, phi_psi, TpT, p;
    
    S := Source( phi );
    
    if not IsIdenticalObj( S, Source( psi ) ) then
        Error( "the two morphisms must have identical source modules\n" );
    fi;
    
    phi_psi := UnionOfRows( MatrixOfMap( phi ), MatrixOfMap( psi ) );
    
    TpT := Range( phi ) + Range( psi );
    
    ## get the position of the set of relations immediately after creating TpT;
    p := Genesis( TpT ).("PositionOfTheDefaultSetOfRelationsOfTheOutput");
    
    phi_psi := HomalgMap( phi_psi, S, [ TpT, p ] );
    
    if HasIsMonomorphism( phi ) and IsMonomorphism( phi ) and
       HasIsMorphism( psi ) and IsMorphism( psi ) then
        SetIsMonomorphism( phi_psi, true );
    elif HasIsMorphism( phi ) and IsMorphism( phi ) and
       HasIsMonomorphism( psi ) and IsMonomorphism( psi ) then
        SetIsMonomorphism( phi_psi, true );
    elif HasIsMorphism( phi ) and IsMorphism( phi ) and
       HasIsMorphism( psi ) and IsMorphism( psi ) then
        SetIsMorphism( phi_psi, true );
    fi;
    
    return phi_psi;
    
end );

## from HomalgBicomplex.gi

            morphism_aids := rec( );	## this allows us to view the split monos (for q = 0) as generalized embeddings in the (first) filtration of the double complex (see GrothendieckSpectralSequence)
                morphism_aids.(String(bidegrees_source[2])) := MonoOfLeftSummand( S );
                morphism_aids.(String(bidegrees_source[l])) := MonoOfLeftSummand( S );
            S!.MorphismAidMapsInObjectOfTotalComplex := morphism_aids;
            morphism_aids := rec( );	## this allows us to view the split monos (for q = 0) as generalized embeddings in the (first) filtration of the double complex (see GrothendieckSpectralSequence)
                morphism_aids.(String(bidegrees_target[2])) := MonoOfLeftSummand( T );
                morphism_aids.(String(bidegrees_target[l])) := MonoOfLeftSummand( T );
            T!.MorphismAidMapsInObjectOfTotalComplex := morphism_aids;

## from SpectralSequences.gi

            ## stack all morphism aid maps together
            if HasMorphismAidMap( gen_emb2 ) then
                if IsHomalgMap( monomorphism_aid_map ) then
                    monomorphism_aid_map := StackMaps( monomorphism_aid_map, MorphismAidMap( gen_emb2 ) );
                else
                    monomorphism_aid_map := MorphismAidMap( gen_emb2 );
                fi;
            fi;
           
        ## store the monomorphism_aid_map in all the generalized embeddings
        ## of the second spectral sequence
        if IsHomalgMap( monomorphism_aid_map ) then
            for pq in bidegrees do
                
                q := pq[1];		## we flip p and q of the bicomplex since we take
                p := pq[2];		## the second spectral sequence as our reference
                
                gen_emb2 := grothendieck2.(String([ p, q ]));
                
                RemoveMorphismAidMap( gen_emb2 );
                
                SetMorphismAidMap( gen_emb2, monomorphism_aid_map );
                
            od;
        fi;
        
##
InstallMethod( GrothendieckSpectralSequence,
        "for homalg maps",
        [ IsHomalgFunctorRep, IsHomalgFunctorRep, IsFinitelyPresentedModuleRep ],
        
  function( Functor_F, Functor_G, M )
    local F, G, P, GP, CE, FCE, BC, Tot, H, I_E, tBC, II_E, I_E2, II_E2,
          II_E_infinity, grothendieck, grothendieck1, grothendieck2,
          n, ToTn, bidegrees, l, pq, p, q, tot_embs, gen_emb0,
          gen_emb1, gen_emb2, gen_emb, monomorphism_aid_map, gen_map;
    
    F := OperationOfFunctor( Functor_F );
    G := OperationOfFunctor( Functor_G );
    
    ## a projective resolution of M
    ## (which is an injective resolution in the opposite category)
    P := Resolution( M );
    
    ## apply the inner functor G to the resolution P of M
    GP := G( P );
    
    ## compute the Cartan-Eilenberg resolution of P
    CE := Resolution( GP );
    
    ## apply the outer functor F to the Cartan-Eilenberg resolution
    FCE := F( CE );
    
    ## the associated bicomplex
    BC := HomalgBicomplex( FCE );
    
    ## the associated total complex
    Tot := TotalComplex( BC );
    
    ## the (co)homology graded object of the total complex:
    H := DefectOfExactness( Tot );
    
    ## test for zero defects in H:
    IsZero( H );
    
    ## the spectral sequence associated to BC,
    ## also called the first spectral sequence of the bicomplex BC;
    ## its limit sheet is the second sheet,
    ## where it also becomes intrinsic (in the abelian category)
    I_E := HomalgSpectralSequence( BC );
    
    ## the transposed bicomplex associated to FCE
    tBC := TransposedBicomplex( BC );
    
    ## the spectral sequence associated to tBC,
    ## also called the second spectral sequence of the bicomplex BC;
    ## it becomes intrinsic at the second level R^(-p) F R^q G => L_(p+q) FG
    II_E := HomalgSpectralSequence( tBC, 2 );
    
    ## the limit sheet of the first spectral sequence
    I_E2 := CertainSheet( I_E, 2 );
    
    ## the intrinsic sheet of the second spectral sequence
    II_E2 := CertainSheet( II_E, 2 );
    
    ## the limit sheet of the second spectral sequence
    II_E_infinity := HighestLevelSheetInSpectralSequence( II_E );
    
    grothendieck := rec( );
    grothendieck1 := rec( );
    grothendieck2 := rec( );
    
    for n in Filtered( ObjectDegreesOfComplex( Tot ), j -> j >= 0 ) do	## the (co)homologies vanish in negative total degrees
        
        ToTn := CertainObject( Tot, n );
        
        if IsBound( ToTn!.EmbeddingsInObjectOfTotalComplex ) then
            tot_embs := ToTn!.EmbeddingsInObjectOfTotalComplex;
        else
            tot_embs := fail;	## happens at the ends of the total complex
        fi;
        
        gen_emb0 := NaturalGeneralizedEmbedding( CertainObject( H, n ) );
        
        ## for the first spectral sequence I_E
        gen_emb1 := I_E2!.absolute_embeddings.(String([ n, 0 ]));
        
        if tot_embs <> fail then
            gen_emb1 := PreCompose( gen_emb1, tot_embs.(String([ n, 0 ])) );
        fi;
        
        ## this is the isomorphism I_E^{n,0} = H^n( Tot( BC ) )
        gen_emb1 := gen_emb1 / gen_emb0;
        
        ## check assertion
        Assert( 1, IsIsomorphism( gen_emb1 ) );
        
        SetIsIsomorphism( gen_emb1, true );
        
        grothendieck1.(String([ n, 0 ])) := gen_emb1;
        
        ## for the second spectral sequence II_E
        bidegrees := BidegreesOfObjectOfTotalComplex( BC, n );
        
        l := Length( bidegrees );
        
        monomorphism_aid_map := 0;
        
        for pq in bidegrees do
            
            q := pq[1];		## we flip p and q of the bicomplex since we take
            p := pq[2];		## the second spectral sequence as our reference
            
            gen_emb2 := II_E_infinity!.absolute_embeddings.(String([ p, q ]));
            
            if tot_embs <> fail then
                gen_emb2 := PreCompose( gen_emb2, tot_embs.(String([ q, p ])) );	## note the flip [ q, p ]
            fi;
            
            ## this is the generalized embedding of II_E^{p,q} into H^{p+q}( Tot( BC ) )
            gen_emb2 := gen_emb2 / gen_emb0;
            
            SetIsGeneralizedMonomorphism( gen_emb2, true );
            
            ## at least the highest is a monomorphism
            IsMonomorphism( gen_emb2 );
            
            grothendieck2.(String([ p, q ])) := gen_emb2;
            
        od;
        
        monomorphism_aid_map := 0;
        
        for pq in Reversed( bidegrees ) do		## note the "Reversed"
            
            q := pq[1];		## we flip p and q of the bicomplex since we take
            p := pq[2];		## the second spectral sequence as our reference
            
            gen_emb := grothendieck2.(String([ p, q ])) / grothendieck1.(String([ n, 0 ]));
            
            ## start to make the gen_emb's the generalized embeddings
            ## of the filtration induced by the second spectral sequence
            gen_map := HomalgMap( MatrixOfMap( gen_emb ), "free", Range( gen_emb ) );
            
            if IsHomalgMap( monomorphism_aid_map ) then
                SetMorphismAidMap( gen_emb, monomorphism_aid_map );
                monomorphism_aid_map := StackMaps( monomorphism_aid_map, gen_map );
            else
                monomorphism_aid_map := gen_map;
            fi;
            
            ## IsIsomorphism would first checks IsEpimorphism and if false
            ## it would simply return false without cheching IsMonomorphism
            IsEpimorphism( gen_emb );
            IsMonomorphism( gen_emb );
            
            ## at least the lowest one is a generalized isomrphism
            IsGeneralizedIsomorphism( gen_emb );
            
            ## check assertion
            Assert( 1, IsGeneralizedMonomorphism( gen_emb ) );
            
            SetIsGeneralizedMonomorphism( gen_emb, true );
            
            grothendieck.(String([ p, q ])) := gen_emb;
            
        od;
        
        ## the lowest one is a generalized isomorphism
        p := bidegrees[1][2];
        q := bidegrees[1][1];
        
        ## check assertion
        Assert( 1, IsGeneralizedIsomorphism( grothendieck.(String([ p, q ])) ) );
        
        SetIsGeneralizedIsomorphism( grothendieck.(String([ p, q ])), true );
        
        ## the higest one is a monomorphism
        p := bidegrees[l][2];
        q := bidegrees[l][1];
        
        ## check assertion
        Assert( 1, IsMonomorphism( grothendieck.(String([ p, q ])) ) );
        
        SetIsMonomorphism( grothendieck.(String([ p, q ])), true );
        
    od;
    
    ## first enrich I_E
    SetGeneralizedEmbeddingsInTotalObjects( I_E, grothendieck1 );
    
    ## now its time to enrich II_E
    SetGeneralizedEmbeddingsInTotalObjects( II_E, grothendieck2 );
    
    ## even with
    II_E!.FirstSpectralSequence := I_E;
    
    ## and finally
    II_E!.GeneralizedEmbeddingsInStableSecondSheetOfFirstSpectralSequence := grothendieck;
    
    return II_E;
    
end );

## from HomalgMap.gd/gi

DeclareOperation( "RemoveMorphismAidMap",
        [ IsHomalgMap ] );

DeclareOperation( "ReplaceMorphismAidMap",
        [ IsHomalgMap, IsObject ] );

##
InstallMethod( RemoveMorphismAidMap,
        "for homalg maps",
        [ IsMapOfFinitelyGeneratedModulesRep ],
        
  function( phi )
    
    ResetFilterObj( phi, MorphismAidMap );
    Unbind( phi!.MorphismAidMap );
    
end );

## never use this operation unless you know what you are doing
## (together with the caching of the functors PostDivide and Compose
##  it could lead to wrong results)
InstallMethod( ReplaceMorphismAidMap,
        "for homalg maps",
        [ IsMapOfFinitelyGeneratedModulesRep, IsObject ],
        
  function( phi, morphism_aid_map )
    local morphism_aid_map1;
    
    if IsHomalgMap( morphism_aid_map ) then
        
        if not IsIdenticalObj( Range( phi ), Range( morphism_aid_map ) ) then
            Error( "the targets of the two morphisms must coincide\n" );
        fi;
	
        ## we don't need the source of the morphism aid map
        morphism_aid_map1 := OnAFreeSource( morphism_aid_map );
        
        ## first clean up
        RemoveMorphismAidMap( phi );
        
        ## a generalized embedding may now become
	## only a generalized homomorphism
        homalgResetFilters( phi );
        
        SetMorphismAidMap( phi, morphism_aid_map1 );
        
    fi;
    
end );

## from HomalgFiltration.gi

        ## (this also avoids an error that occurs in CompleteImageSquare below
        ##  this pops up during the execution of A3_Purity.g)
        RemoveMorphismAidMap( gen_emb );

## from SpectralSequence.gi

        ## this is necessary for handling not only homological
        ## but also cohomological spectral sequences
        if IsSpectralSequenceOfFinitelyPresentedObjectsRep( II_E ) then
            bidegrees := Reversed( bidegrees );			## note the "Reversed"
        fi;
        
## from HomalgBigradedObject.gi

          Tot, n, Tot_s, Tot_t, bidegrees_s, bidegrees_t,
          tot_embs, tot_prjs;
        if cpx then
            p_degrees := bidegrees[1]{[ r + 1 .. lp ]};
            q_degrees := bidegrees[2]{[ 1 .. lq - ( r - 1 ) ]};
            for p in p_degrees do
                for q in q_degrees do
                    source := CertainObject( Er, [ p, q ] );
                    target := CertainObject( Er, [ p, q ] + bidegree );
                    if not ForAny( [ source, target ], IsZero ) then
                        mor_h := List( [ 0 .. r - 1 ], i -> CertainHorizontalMorphism( B, [ p - i, q + i ] ) );
                        mor_v := List( [ 1 .. r - 1 ], i -> CertainVerticalMorphism( B, [ p - i, q + i ] ) );
                        if ForAny( mor_h, IsZero ) or ForAny( mor_v, IsZero ) then
                            mor := TheZeroMap( source, target );
                        else
                            emb_source := Er!.absolute_embeddings.(String( [ p, q ] ));
                            emb_target := Er!.absolute_embeddings.(String( [ p, q ] + bidegree ));
                            if r > 1 then
                                ## the associated total complex
                                Tot := TotalComplex( B );
                                
                                n := p + q;
                                
                                ## the n-th total object
                                Tot_s := CertainObject( Tot, n );
                                
                                ## the (n-1)-st total object
                                Tot_t := CertainObject( Tot, n - 1 );
                                
                                ## the bidegrees of total degree n
                                bidegrees_s := BidegreesOfObjectOfTotalComplex( B, n );
                                
                                ## the bidegrees of total degree n - 1
                                bidegrees_t := BidegreesOfObjectOfTotalComplex( B, n - 1 );
                                
                                ## the embeddings from B_{p,q} -> Tot_n
                                tot_embs := EmbeddingsInCoproductObject( Tot_s, bidegrees_s );
                                
                                ## the projections from Tot_n -> B_{p,q}
                                tot_prjs := ProjectionsFromProductObject( Tot_t, bidegrees_t );
                                
                                if tot_embs <> fail then
                                    emb_source := PreCompose( emb_source, tot_embs.(String([ p, q ])) );
                                fi;
                                
                                mor := PreCompose( emb_source, MorphismOfTotalComplex( B, n ) );
                                
                                if tot_prjs <> fail then
                                    mor := PreCompose( mor, tot_prjs.(String([ p, q ] + bidegree )) );
                                fi;
                                
                            else
                                mor := PreCompose( emb_source, mor_h[1] );
                            fi;
                            mor := mor / emb_target;
                        fi;
                        Assert( 1, IsMorphism( mor ) );
                        SetIsMorphism( mor, true );
                        Er!.(String( [ p, q ] )) := mor;
                    fi;
                od;
            od;
        else
            p_degrees := bidegrees[1]{[ 1 .. lp - r ]};
            q_degrees := bidegrees[2]{[ r .. lq ]};
            for p in p_degrees do
                for q in q_degrees do
                    source := CertainObject( Er, [ p, q ] );
                    target := CertainObject( Er, [ p, q ] + bidegree );
                    if not ForAny( [ source, target ], IsZero ) then
                        mor_h := List( [ 0 .. r - 1 ], i -> CertainHorizontalMorphism( B, [ p + i, q - i ] ) );
                        mor_v := List( [ 1 .. r - 1 ], i -> CertainVerticalMorphism( B, [ p + i, q - i ] ) );
                        if ForAny( mor_h, IsZero ) or ForAny( mor_v, IsZero ) then
                            mor := TheZeroMap( source, target );
                        else
                            emb_source := Er!.absolute_embeddings.(String( [ p, q ] ));
                            emb_target := Er!.absolute_embeddings.(String( [ p, q ] + bidegree ));
                            if r > 1 then
                                ## the associated total complex
                                Tot := TotalComplex( B );
                                
                                n := p + q;
                                
                                ## the n-th total object
                                Tot_s := CertainObject( Tot, n );
                                
                                ## the (n+1)-st total object
                                Tot_t := CertainObject( Tot, n + 1 );
                                
                                ## the bidegrees of total degree n
                                bidegrees_s := BidegreesOfObjectOfTotalComplex( B, n );
                                
                                ## the bidegrees of total degree n + 1
                                bidegrees_t := BidegreesOfObjectOfTotalComplex( B, n + 1 );
                                
                                ## the embeddings from B^{p,q} -> Tot^n
                                tot_embs := EmbeddingsInCoproductObject( Tot_s, bidegrees_s );
                                
                                ## the projections from Tot^n -> B^{p,q}
                                tot_prjs := ProjectionsFromProductObject( Tot_t, bidegrees_t );
                                
                                if tot_embs <> fail then
                                    emb_source := PreCompose( emb_source, tot_embs.(String([ p, q ])) );
                                fi;
                                
                                mor := PreCompose( emb_source, MorphismOfTotalComplex( B, n ) );
                                
                                if tot_prjs <> fail then
                                    mor := PreCompose( mor, tot_prjs.(String([ p, q ] + bidegree )) );
                                fi;
                                
                            else
                                mor := PreCompose( emb_source, mor_h[1] );
                            fi;
                            mor := mor / emb_target;
                        fi;
                        Assert( 1, IsMorphism( mor ) );
                        SetIsMorphism( mor, true );
                        Er!.(String( [ p, q ] )) := mor;
                    fi;
                od;
            od;
        fi;

## from HomalgModule.gd

##  <#GAPDoc Label="IsHomalgGradedModule">
##  <ManSection>
##    <Filt Type="Category" Arg="M" Name="IsHomalgGradedModule"/>
##    <Returns>true or false</Returns>
##    <Description>
##      The &GAP; category of &homalg; graded modules. <Br/><Br/>
##      (It is a subcategory of the &GAP; category <C>IsHomalgModule</C>.)
##    </Description>
##  </ManSection>
##  <#/GAPDoc>
DeclareCategory( "IsHomalgGradedModule",
        IsHomalgModule );

## from HomalgModule.gi
BindGlobal( "TheTypeHomalgLeftGradedFinitelyPresentedModule",
        NewType( TheFamilyOfHomalgModules,
                IsFinitelyPresentedModuleRep and IsHomalgGradedModule and IsHomalgLeftObjectOrMorphismOfLeftObjects ) );

BindGlobal( "TheTypeHomalgRightGradedFinitelyPresentedModule",
        NewType( TheFamilyOfHomalgModules,
                IsFinitelyPresentedModuleRep and IsHomalgGradedModule and IsHomalgRightObjectOrMorphismOfRightObjects ) );

## from doc/Modules.xml
<#Include Label="IsHomalgGradedModule">

## from changes.log
- Resolution (of modules) now does not compute a step ahead
  (unless a trivial next syzygy is expected)

## from Singular.gi
    NonTrivialDegreePerRowWithColWeights := "\n\
proc NonTrivialDegreePerRowWithColWeights (matrix M, list col_weights)\n\
{\n\
  intmat m[1][ncols(M)];\n\
  int d = deg(0);\n\
  for (int i=1; i<=ncols(M); i=i+1)\n\
  {\n\
    if ( deg(M[1,i]) <> d ) { m[1,i] = deg(M[1,i])+col_weights[1]; } else { m[1,i] = -10^9; } // FIXME??\n\
    for (int j=2; j<=nrows(M); j=j+1)\n\
    {\n\
      if ( deg(M[j,i]) <> d && deg(M[j,i])+col_weights[j] > m[1,i] ) { m[1,i] = deg(M[j,i])+col_weights[j]; }\n\
    }\n\
  }\n\
  return(m);\n\
}\n\n";
    
    NonTrivialDegreePerColumnWithRowWeights := "\n\
proc NonTrivialDegreePerColumnWithRowWeights (matrix M, list row_weights)\n\
{\n\
  intmat m[1][nrows(M)];\n\
  int d = deg(0);\n\
  for (int j=1; j<=nrows(M); j=j+1)\n\
  {\n\
    if ( deg(M[j,1]) <> d ) { m[1,j] = deg(M[j,1])+row_weights[1]; } else { m[1,j] = -10^9; } // FIXME?? \n\
    for (int i=2; i<=ncols(M); i=i+1)\n\
    {\n\
      if ( deg(M[j,i]) <> d && deg(M[j,i])+row_weights[i] > m[1,j] ) { m[1,j] = deg(M[j,i])+row_weights[i]; }\n\
    }\n\
  }\n\
  return(m);\n\
}\n\n";
    
    homalgSendBlocking( NonTrivialDegreePerRowWithColWeights, "need_command", stream, HOMALG_IO.Pictograms.define );
    homalgSendBlocking( NonTrivialDegreePerColumnWithRowWeights, "need_command", stream, HOMALG_IO.Pictograms.define );

## from SingularTools.gi
               NonTrivialDegreePerRowWithColWeights :=
                 function( M, col_weights )
                   local list_string;
                   
                   list_string := homalgSendBlocking( [ "NonTrivialDegreePerRowWithColWeights(", M, ", list (", col_weights, "))" ], "need_output", HOMALG_IO.Pictograms.DegreeMultivariatePolynomial );
                   
                   return StringToIntList( list_string );
                   
                 end,
               
               NonTrivialDegreePerColumnWithRowWeights :=
                 function( M, row_weights )
                   local list_string;
                   
                   list_string := homalgSendBlocking( [ "NonTrivialDegreePerColumnWithRowWeights(", M, ", list (", row_weights, "))" ], "need_output", HOMALG_IO.Pictograms.DegreeMultivariatePolynomial );
                   
                   return StringToIntList( list_string );
                   
                 end,
               
## from HomalgRelations.gd
##  <#GAPDoc Label="IsReducedSetOfRelations">
##  <ManSection>
##    <Prop Arg="rel" Name="IsReducedSetOfRelations"/>
##    <Returns>true or false</Returns>
##    <Description>
##      Check if the &homalg; set of relations <A>rel</A> is marked reduced. <Br/>
##      (no method installed)
##    </Description>
##  </ManSection>
##  <#/GAPDoc>
##
DeclareProperty( "IsReducedSetOfRelations",
        IsHomalgRelations );

## from HomalgRing.gi

##
InstallMethod( ViewObj,
        "for homalg external rings",
        [ IsHomalgExternalRingRep ],
        
  function( o )
    
    Print( "<A homalg external ring residing in the CAS " );
    Print( homalgExternalCASystem( o ), ">" );
    
end );

## from Tools.gi

## --> IsZero

    else
        return homalgPointer( r ) = homalgPointer( Zero( R ) ); ## FIXME

## --> IsOne

    else
        return homalgPointer( r ) = homalgPointer( One( R ) ); ## FIXME

## from HomalgRelations.gd/gi

DeclareOperation( "DecideZeroEffectively",
        [ IsHomalgMatrix, IsHomalgRelations ] );

DeclareSynonym ( "ReduceCoeff",
        DecideZeroEffectively );

##
InstallMethod( DecideZeroEffectively,
        "modulo a set of relations of a homalg module",
        [ IsHomalgMatrix,
          IsRelationsOfFinitelyPresentedModuleRep and IsHomalgRelationsOfLeftModule ],
        
  function( mat, rel )
    
    return DecideZeroRowsEffectively( mat, MatrixOfRelations( BasisOfModule( rel ) ) );
    
end );

##
InstallMethod( DecideZeroEffectively,
        "modulo a set of relations of a homalg module",
        [ IsHomalgMatrix,
          IsRelationsOfFinitelyPresentedModuleRep and IsHomalgRelationsOfRightModule ],
        
  function( mat, rel )
    
    return DecideZeroColumnsEffectively( mat, MatrixOfRelations( BasisOfModule( rel ) ) );
    
end );

## from HomalgModule.gd/gi

DeclareOperation( "DecideZeroEffectively",
        [ IsHomalgMatrix, IsHomalgModule ] );

##
InstallMethod( DecideZeroEffectively,
        "for homalg modules",
        [ IsHomalgMatrix, IsFinitelyPresentedModuleRep ],
        
  function( mat, M )
    local rel;
    
    rel := RelationsOfModule( M );
    
    return DecideZeroEffectively( mat, rel );
    
end );

## from SetsOfRelations.gd

####################################
#
# function-operation-Attribute triples
#
####################################

KeyDependentOperation( "TransitionMap", IsSetsOfRelations, IsList, ReturnTrue );

## from SpectralSequences.gd/gi

DeclareOperation( "AddSpectralFiltrationOfTotalDefectsUsingProjections",
        [ IsHomalgSpectralSequenceAssociatedToAFilteredComplex, IsList ] );

DeclareOperation( "AddSpectralFiltrationOfTotalDefectsUsingProjections",
        [ IsHomalgSpectralSequenceAssociatedToAFilteredComplex ] );

DeclareOperation( "SpectralSequenceWithFiltrationOfTotalDefectsUsingProjections",
        [ IsHomalgBicomplex, IsInt, IsList ] );

DeclareOperation( "SpectralSequenceWithFiltrationOfTotalDefectsUsingProjections",
        [ IsHomalgBicomplex, IsList ] );

DeclareOperation( "SpectralSequenceWithFiltrationOfTotalDefectsUsingProjections",
        [ IsHomalgBicomplex, IsInt ] );

DeclareOperation( "SpectralSequenceWithFiltrationOfTotalDefectsUsingProjections",
        [ IsHomalgBicomplex ] );

##
InstallMethod( AddSpectralFiltrationOfTotalDefectsUsingProjections,
        "for homalg spectral sequences",
        [ IsHomalgSpectralSequenceAssociatedToABicomplex, IsList ],
        
  function( E, p_range )
    local E_infinity, embeddings, BC, Tot, filtration, n, Totn, Hn, Hgen_emb,
          bidegrees, tot_prjs, pq, pp, qq, p, q, gen_emb, gen_prj, gen_embH;
    
    ## the limit sheet of the spectral sequence
    E_infinity := HighestLevelSheetInSpectralSequence( E );
    
    ## get the absolute embeddings
    embeddings := E_infinity!.absolute_embeddings;
    
    ## the associated bicomplex
    BC := UnderlyingBicomplex( E );
    
    ## the associated total complex
    Tot := TotalComplex( BC );
    
    filtration := rec( );
    
    for n in p_range do
        
        ## the n-th total object
        Totn := CertainObject( Tot, n );
        
        ## the n-th total (co)homology
        Hn := DefectOfExactness( Tot, n );
        
        ## the n-th generalized embedding
        Hgen_emb := NaturalGeneralizedEmbedding( Hn );
        
        ## the bidegrees of total degree n
        bidegrees := BidegreesOfObjectOfTotalComplex( BC, n );
        
        ## the projections from Tot^n -> BC^{p,q}
        tot_prjs := ProjectionsFromProductObject( Totn, bidegrees );
        
        for pq in bidegrees do
            
            pp := pq[1];
            qq := pq[2];
            
            if IsTransposedWRTTheAssociatedComplex( BC ) then
                p := qq;
                q := pp;
            else
                p := pp;
                q := qq;
            fi;
            
            gen_emb := embeddings.(String( [ p, q ] ));
            
            if tot_prjs <> fail then
                gen_prj := PreCompose( Hgen_emb, tot_prjs.(String( [ pp, qq ] )) );
            else
                gen_prj := Hgen_emb;
            fi;
            
            gen_embH := gen_emb / gen_prj;
            
            filtration.(String( [ p, q ] )) := gen_embH;
            
        od;
        
    od;
    
    ## enrich E
    SetGeneralizedEmbeddingsInTotalDefects( E, filtration );
    
    return E;
    
end );

##
InstallMethod( AddSpectralFiltrationOfTotalDefectsUsingProjections,
        "for homalg spectral sequences",
        [ IsHomalgSpectralSequenceAssociatedToABicomplex ],
        
  function( E )
    local BC, p_range;
    
    BC := UnderlyingBicomplex( E );
    
    p_range := TotalObjectDegreesOfBicomplex( BC );
    
    return AddSpectralFiltrationOfTotalDefectsUsingProjections( E, p_range );
    
end );

##
InstallMethod( SpectralSequenceWithFiltrationOfTotalDefectsUsingProjections,
        "for homalg bicomplexes",
        [ IsHomalgBicomplex, IsInt, IsList ],
        
  function( BC, a, p_range )
    local E;
    
    #=====# begin of the core procedure #=====#
    
    E := HomalgSpectralSequence( BC, a );
    
    ## filter the total defects with the stable objects
    ## of the second spectral sequence
    AddSpectralFiltrationOfTotalDefectsUsingProjections( E, p_range );
    
    return E;
    
end );

##
InstallMethod( SpectralSequenceWithFiltrationOfTotalDefectsUsingProjections,
        "for homalg bicomplexes",
        [ IsHomalgBicomplex, IsList ],
        
  function( BC, p_range )
    
    return SpectralSequenceWithFiltrationOfTotalDefectsUsingProjections( BC, -1, p_range );
    
end );

##
InstallMethod( SpectralSequenceWithFiltrationOfTotalDefectsUsingProjections,
        "for homalg bicomplexes",
        [ IsHomalgBicomplex, IsInt ],
        
  function( BC, a )
    local p_range;
    
    p_range := TotalObjectDegreesOfBicomplex( BC );
    
    return SpectralSequenceWithFiltrationOfTotalDefectsUsingProjections( BC, a, p_range );
    
end );

##
InstallMethod( SpectralSequenceWithFiltrationOfTotalDefectsUsingProjections,
        "for homalg bicomplexes",
        [ IsHomalgBicomplex ],
        
  function( BC )
    
    return SpectralSequenceWithFiltrationOfTotalDefectsUsingProjections( BC, -1 );
    
end );

## from HomalgModule.gi
##
InstallMethod( PrintObj,
        "for homalg modules",
        [ IsFinitelyPresentedModuleRep and IsHomalgLeftObjectOrMorphismOfLeftObjects ],
        
  function( M )
    
    Print( "LeftPresentation( " );
    if HasIsZero( M ) and IsZero( M ) then
        Print( "[ ], ", LeftActingDomain( M ) ); ## no generators, empty relations, ring
    else
        Print( GeneratorsOfModule( M ), ", " );
        if RelationsOfModule( M ) = "unknown relations" then
            Print( "[ ], " ); ## empty relations
        else
            Print( RelationsOfModule( M ), ", " );
        fi;
        Print( LeftActingDomain( M ), " " );
    fi;
    Print( ")" );
    
end );

##
InstallMethod( PrintObj,
        "for homalg modules",
        [ IsFinitelyPresentedModuleRep and IsHomalgRightObjectOrMorphismOfRightObjects ],
        
  function( M )
    
    Print( "RightPresentation( " );
    if HasIsZero( M ) and IsZero( M ) then
        Print( "[ ], ", RightActingDomain( M ) ); ## no generators, empty relations, ring
    else
        Print( GeneratorsOfModule( M ), ", " );
        if RelationsOfModule( M ) = "unknown relations" then
            Print( "[ ], " ); ## empty relations
        else
            Print( RelationsOfModule( M ), ", " );
        fi;
        Print( RightActingDomain( M ), " " );
    fi;
    Print( ")" );
    
end );

## from HomalgModule.gd

##  <#GAPDoc Label="ResidueClassRing">
##  <ManSection>
##    <Attr Arg="J" Name="ResidueClassRing" Label="for ideals"/>
##    <Returns>a &homalg; ring</Returns>
##    <Description>
##      The residue class ring <M>R/</M><A>J</A>, where <A>J</A> is an ideal in the &homalg; ring <M>R</M>.
##    </Description>
##  </ManSection>
##  <#/GAPDoc>
##
DeclareAttribute( "ResidueClassRing",
        IsHomalgModule );

## from LIMOD.gi

##
InstallMethod( ResidueClassRing,
        "for homalg submodules",
        [ IsFinitelyPresentedModuleOrSubmoduleRep ],
        
  function( rel_ideal )
    local R, S, mat, left, rel, rel_old, mat_old, left_old, c;
    
    R := HomalgRing( rel_ideal );
    
    S := CallFuncList( CreateHomalgRing, R!.ConstructorArguments );
    
    mat := MatrixOfGenerators( rel_ideal );
    
    mat := mat * S;
    
    left := IsHomalgLeftObjectOrMorphismOfLeftObjects( rel_ideal );
    
    if left then
        rel := HomalgRelationsForLeftModule( mat );
    else
        rel := HomalgRelationsForRightModule( mat );
    fi;
    
    ## merge the new relations with the relations of the ambient ring
    if HasRingRelations( R ) then
        SetAmbientRing( S, AmbientRing( R ) );
        rel_old := RingRelations( R );
        mat_old := MatrixOfRelations( rel_old );
        mat_old := mat_old * S;
        left_old := IsHomalgRelationsOfLeftModule( rel_old );
        if left_old then
            rel_old := HomalgRelationsForLeftModule( mat_old );
        else
            rel_old := HomalgRelationsForRightModule( mat_old );
        fi;
        if left <> left_old then
            Error( "the relations of the ambient ring and the given relations must both be either left or right relations\n" );
        fi;
        rel := BasisOfModule( UnionOfRelations( rel_old, rel ) );
    else
        SetAmbientRing( S, R );
    fi;
    
    SetRingRelations( S, rel );
    
    ## residue class rings of the integers
    if HasIsResidueClassRingOfTheIntegers( R ) and
       IsResidueClassRingOfTheIntegers( R ) then
        SetIsResidueClassRingOfTheIntegers( S, true );
        c := RingRelations( S );
        c := MatrixOfRelations( c );
        c := EntriesOfHomalgMatrix( c );
        if Length( c ) = 1 then
            c := c[1];
            if IsHomalgRingElement( c ) and
               IsInt( homalgPointer( c ) ) then
                c := homalgPointer( c );
            fi;
        fi;
        if IsInt( c ) then
            SetRingProperties( S, c );
        fi;
    fi;
    
    SetIdealOfRelations( S, rel_ideal );
    
    return S;
    
end );

## from change.log

- declared the attribute ResidueClassRing and
  installed it for submodules as the primary constructor
  method for residue class rings

## from BasicFunctors.gi

    local pre, post, M, p, gen, rel, coker, ker, emb;
    
    if not IsATwoSequence( cpx_post_pre ) then
        Error( "expecting a complex containing two morphisms marked as IsATwoSequence\n" );
    fi;
    
    pre := HighestDegreeMorphism( cpx_post_pre );
    post := LowestDegreeMorphism( cpx_post_pre );
    
    M := Range( pre );
    
    ## this is probably obsolete but clarifies our idea:
    p := PositionOfTheDefaultSetOfGenerators( M );	## avoid future possible side effects of the following command(s)
    
    gen := GeneratorsOfModule( M );
    
    rel := UnionOfRelations( pre );
    
    gen := UnionOfRelations( gen, rel * MatrixOfGenerators( gen ) );
    
    coker := Presentation( gen, rel );
    
    ## this following keeps track of the original generators:
    ker := ReducedSyzygiesGenerators( post ) / coker;	## the number of generators of ker might be less than the number of computed syzygies
    
    ## emb is the matrix of the "natural embedding" (see below)
    ## w.r.t. the first set of relations of ker and the p-th set of relations of M
    emb := MatrixOfGenerators( ker, 1 );
    
    ## this is in general NOT a morphism,
    ## BUT it is one modulo the image of pre in M, and then even a monomorphism:
    ## this is enough for us since we will always view it this way (cf. [BR, 3.1.1,(2), 3.1.2] )
    emb := HomalgMap( emb, [ ker, 1 ], [ M, p ] );
    SetMorphismAidMap( emb, pre );
    
    ## check assertion
    Assert( 4, IsGeneralizedMonomorphism( emb ) );
    
    SetIsGeneralizedMonomorphism( emb, true );
    
    ## save the natural embedding in the defect (thanks GAP):
    ker!.NaturalGeneralizedEmbedding := emb;
    
    return ker;
    
