<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (MatricesForHomalg) - Appendix C: Logic Subpackages</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chapC"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chapA_mj.html">A</a>  <a href="chapB_mj.html">B</a>  <a href="chapC_mj.html">C</a>  <a href="chapD_mj.html">D</a>  <a href="chapE_mj.html">E</a>  <a href="chapF_mj.html">F</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chapB_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapD_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chapC.html">[MathJax off]</a></p>
<p><a id="X8222352C78A19214" name="X8222352C78A19214"></a></p>
<div class="ChapSects"><a href="chapC_mj.html#X8222352C78A19214">C <span class="Heading">Logic Subpackages</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapC_mj.html#X86BB747287348853">C.1 <span class="Heading"><strong class="pkg">LIRNG</strong>: Logical Implications for Rings</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapC_mj.html#X7B2915F1867EE8D0">C.2 <span class="Heading"><strong class="pkg">LIMAP</strong>: Logical Implications for Ring Maps</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapC_mj.html#X799DA94B849ABF1E">C.3 <span class="Heading"><strong class="pkg">LIMAT</strong>: Logical Implications for Matrices</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapC_mj.html#X847B8AB5843231C2">C.4 <span class="Heading"><strong class="pkg">COLEM</strong>: Clever Operations for Lazy Evaluated Matrices</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapC_mj.html#X7EEAADA6807A5A45">C.4-1 Eval</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapC_mj.html#X7B619CA885024F0F">C.4-2 Eval</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapC_mj.html#X7EADAA3180A84318">C.4-3 Eval</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapC_mj.html#X78CCA57B84E51834">C.4-4 Eval</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapC_mj.html#X8362669D87FD667B">C.4-5 Eval</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapC_mj.html#X84D72DF482F70AD5">C.4-6 Eval</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapC_mj.html#X7928991E8768FA72">C.4-7 Eval</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapC_mj.html#X78D5359480EFC5AC">C.4-8 Eval</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapC_mj.html#X87BF7FD083D0EE88">C.4-9 Eval</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapC_mj.html#X852DCBD57A742FA5">C.4-10 Eval</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapC_mj.html#X835F6F2E7D590F3D">C.4-11 Eval</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapC_mj.html#X7F35A61C8522A1B0">C.4-12 Eval</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapC_mj.html#X7EDE6095820F8128">C.4-13 Eval</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapC_mj.html#X7FD68F43831046B6">C.4-14 Eval</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapC_mj.html#X84F45FB4854A079C">C.4-15 Eval</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapC_mj.html#X78ADE5C879583E7B">C.4-16 Eval</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapC_mj.html#X7B68797C7EA79B10">C.4-17 Eval</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapC_mj.html#X85971C16868BD83C">C.4-18 Eval</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapC_mj.html#X86F848318791595C">C.4-19 Eval</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapC_mj.html#X7F7682FC86F602C2">C.4-20 Eval</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapC_mj.html#X848FE4F07BAF89DB">C.4-21 Eval</a></span>
</div></div>
</div>

<h3>C <span class="Heading">Logic Subpackages</span></h3>

<p><a id="X86BB747287348853" name="X86BB747287348853"></a></p>

<h4>C.1 <span class="Heading"><strong class="pkg">LIRNG</strong>: Logical Implications for Rings</span></h4>

<p><a id="X7B2915F1867EE8D0" name="X7B2915F1867EE8D0"></a></p>

<h4>C.2 <span class="Heading"><strong class="pkg">LIMAP</strong>: Logical Implications for Ring Maps</span></h4>

<p><a id="X799DA94B849ABF1E" name="X799DA94B849ABF1E"></a></p>

<h4>C.3 <span class="Heading"><strong class="pkg">LIMAT</strong>: Logical Implications for Matrices</span></h4>

<p><a id="X847B8AB5843231C2" name="X847B8AB5843231C2"></a></p>

<h4>C.4 <span class="Heading"><strong class="pkg">COLEM</strong>: Clever Operations for Lazy Evaluated Matrices</span></h4>

<p>Most of the matrix tool operations listed in Appendix <a href="chapB_mj.html#X7988F0AF7D87FD23"><span class="RefLink">B.1</span></a> which return a new matrix are lazy evaluated. The value of a <strong class="pkg">homalg</strong> matrix is stored in the attribute <code class="code">Eval</code>. Below is the list of the installed methods for the attribute <code class="code">Eval</code>.</p>

<p><a id="X7EEAADA6807A5A45" name="X7EEAADA6807A5A45"></a></p>

<h5>C.4-1 Eval</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Eval</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the <code class="code">Eval</code> value of a <strong class="pkg">homalg</strong> matrix <var class="Arg">C</var></p>

<p>In case the matrix <var class="Arg">C</var> was created using <code class="func">HomalgInitialMatrix</code> (<a href="chap5_mj.html#X86D290B084AC6638"><span class="RefLink">5.2-1</span></a>) then the filter <code class="code">IsInitialMatrix</code> for <var class="Arg">C</var> is set to true and the <code class="code">homalgTable</code> function (--&gt; <code class="func">InitialMatrix</code> (<a href="chapB_mj.html#X7DBA33F083A317B5"><span class="RefLink">B.1-1</span></a>)) will be used to set the attribute <code class="code">Eval</code> and resets the filter <code class="code">IsInitialMatrix</code>.</p>


<div class="example"><pre>
InstallMethod( Eval,
        "for homalg matrices (IsInitialMatrix)",
        [ IsHomalgMatrix and IsInitialMatrix and
          HasNrRows and HasNrColumns ],
        
  function( C )
    local R, RP, z, zz;
    
    R := HomalgRing( C );
    
    RP := homalgTable( R );
    
    if IsBound( RP!.InitialMatrix ) then
        ResetFilterObj( C, IsInitialMatrix );
        SetEval( C, RP!.InitialMatrix( C ) );
        return Eval( C );
    fi;
    
    if not IsHomalgInternalMatrixRep( C ) then
        Error( "could not find a procedure called InitialMatrix in the ",
               "homalgTable to evaluate a non-internal initial matrix\n" );
    fi;
    
    #=====# can only work for homalg internal matrices #=====#
    
    z := Zero( HomalgRing( C ) );
    
    ResetFilterObj( C, IsInitialMatrix );
    
    zz := ListWithIdenticalEntries( NrColumns( C ), z );
    
    SetEval( C, homalgInternalMatrixHull( List( [ 1 .. NrRows( C ) ], i -&gt; ShallowCopy( zz ) ) ) );
    
    return Eval( C );
    
end );
</pre></div>

<p><a id="X7B619CA885024F0F" name="X7B619CA885024F0F"></a></p>

<h5>C.4-2 Eval</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Eval</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the <code class="code">Eval</code> value of a <strong class="pkg">homalg</strong> matrix <var class="Arg">C</var></p>

<p>In case the matrix <var class="Arg">C</var> was created using <code class="func">HomalgInitialIdentityMatrix</code> (<a href="chap5_mj.html#X7CB77009868D369A"><span class="RefLink">5.2-2</span></a>) then the filter <code class="code">IsInitialIdentityMatrix</code> for <var class="Arg">C</var> is set to true and the <code class="code">homalgTable</code> function (--&gt; <code class="func">InitialIdentityMatrix</code> (<a href="chapB_mj.html#X84179BE87E7DCE76"><span class="RefLink">B.1-2</span></a>)) will be used to set the attribute <code class="code">Eval</code> and resets the filter <code class="code">IsInitialIdentityMatrix</code>.</p>


<div class="example"><pre>
InstallMethod( Eval,
        "for homalg matrices (IsInitialIdentityMatrix)",
        [ IsHomalgMatrix and IsInitialIdentityMatrix and
          HasNrRows and HasNrColumns ],
        
  function( C )
    local R, RP, o, z, zz, id;
    
    R := HomalgRing( C );
    
    RP := homalgTable( R );
    
    if IsBound( RP!.InitialIdentityMatrix ) then
        ResetFilterObj( C, IsInitialIdentityMatrix );
        SetEval( C, RP!.InitialIdentityMatrix( C ) );
        return Eval( C );
    fi;
    
    if not IsHomalgInternalMatrixRep( C ) then
        Error( "could not find a procedure called InitialIdentityMatrix in the ",
               "homalgTable to evaluate a non-internal initial identity matrix\n" );
    fi;
    
    #=====# can only work for homalg internal matrices #=====#
    
    z := Zero( HomalgRing( C ) );
    o := One( HomalgRing( C ) );
    
    ResetFilterObj( C, IsInitialIdentityMatrix );
    
    zz := ListWithIdenticalEntries( NrColumns( C ), z );
    
    id := List( [ 1 .. NrRows( C ) ],
                function(i)
                  local z;
                  z := ShallowCopy( zz ); z[i] := o; return z;
                end );
    
    SetEval( C, homalgInternalMatrixHull( id ) );
    
    return Eval( C );
    
end );
</pre></div>

<p><a id="X7EADAA3180A84318" name="X7EADAA3180A84318"></a></p>

<h5>C.4-3 Eval</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Eval</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the <code class="code">Eval</code> value of a <strong class="pkg">homalg</strong> matrix <var class="Arg">C</var></p>

<p>In case the matrix <var class="Arg">C</var> was created using <code class="func">HomalgZeroMatrix</code> (<a href="chap5_mj.html#X8309EB7B86953A23"><span class="RefLink">5.2-3</span></a>) then the filter <code class="code">IsZeroMatrix</code> for <var class="Arg">C</var> is set to true and the <code class="code">homalgTable</code> function (--&gt; <code class="func">ZeroMatrix</code> (<a href="chapB_mj.html#X785390E38396CAEB"><span class="RefLink">B.1-3</span></a>)) will be used to set the attribute <code class="code">Eval</code>.</p>


<div class="example"><pre>
InstallMethod( Eval,
        "for homalg matrices (IsZero)",
        [ IsHomalgMatrix and IsZero and HasNrRows and HasNrColumns ], 40,
        
  function( C )
    local R, RP, z;
    
    R := HomalgRing( C );
    
    RP := homalgTable( R );
    
    if ( NrRows( C ) = 0 or NrColumns( C ) = 0 ) and
       not ( IsBound( R!.SafeToEvaluateEmptyMatrices ) and
             R!.SafeToEvaluateEmptyMatrices = true ) then
        Info( InfoWarning, 1, "\033[01m\033[5;31;47m",
              "an empty matrix is about to get evaluated!",
              "\033[0m" );
    fi;
    
    if IsBound( RP!.ZeroMatrix ) then
        return RP!.ZeroMatrix( C );
    fi;
    
    if not IsHomalgInternalMatrixRep( C ) then
        Error( "could not find a procedure called ZeroMatrix ",
               "homalgTable to evaluate a non-internal zero matrix\n" );
    fi;
    
    #=====# can only work for homalg internal matrices #=====#
    
    z := Zero( HomalgRing( C ) );
    
    ## copying the rows saves memory;
    ## we assume that the entries are never modified!!!
    return homalgInternalMatrixHull(
                   ListWithIdenticalEntries( NrRows( C ),
                           ListWithIdenticalEntries( NrColumns( C ), z ) ) );
    
end );
</pre></div>

<p><a id="X78CCA57B84E51834" name="X78CCA57B84E51834"></a></p>

<h5>C.4-4 Eval</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Eval</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the <code class="code">Eval</code> value of a <strong class="pkg">homalg</strong> matrix <var class="Arg">C</var></p>

<p>In case the matrix <var class="Arg">C</var> was created using <code class="func">HomalgIdentityMatrix</code> (<a href="chap5_mj.html#X83266B9D7BE740D8"><span class="RefLink">5.2-4</span></a>) then the filter <code class="code">IsOne</code> for <var class="Arg">C</var> is set to true and the <code class="code">homalgTable</code> function (--&gt; <code class="func">IdentityMatrix</code> (<a href="chapB_mj.html#X87BFF3567DEEBEF4"><span class="RefLink">B.1-4</span></a>)) will be used to set the attribute <code class="code">Eval</code>.</p>


<div class="example"><pre>
InstallMethod( Eval,
        "for homalg matrices (IsOne)",
        [ IsHomalgMatrix and IsOne and HasNrRows and HasNrColumns ], 10,
        
  function( C )
    local R, id, RP, o, z, zz;
    
    R := HomalgRing( C );
    
    if IsBound( R!.IdentityMatrices ) then
        id := ElmWPObj( R!.IdentityMatrices!.weak_pointers, NrColumns( C ) );
        if id &lt;&gt; fail then
            R!.IdentityMatrices!.cache_hits := R!.IdentityMatrices!.cache_hits + 1;
            return id;
        fi;
        ## we do not count cache_misses as it is equivalent to counter
    fi;
    
    RP := homalgTable( R );
    
    if IsBound( RP!.IdentityMatrix ) then
        id := RP!.IdentityMatrix( C );
        SetElmWPObj( R!.IdentityMatrices!.weak_pointers, NrColumns( C ), id );
        R!.IdentityMatrices!.counter := R!.IdentityMatrices!.counter + 1;
        return id;
    fi;
    
    if not IsHomalgInternalMatrixRep( C ) then
        Error( "could not find a procedure called IdentityMatrix ",
               "homalgTable to evaluate a non-internal identity matrix\n" );
    fi;
    
    #=====# can only work for homalg internal matrices #=====#
    
    z := Zero( HomalgRing( C ) );
    o := One( HomalgRing( C ) );
    
    zz := ListWithIdenticalEntries( NrColumns( C ), z );
    
    id := List( [ 1 .. NrRows( C ) ],
                function(i)
                  local z;
                  z := ShallowCopy( zz ); z[i] := o; return z;
                end );
    
    id := homalgInternalMatrixHull( id );
    
    SetElmWPObj( R!.IdentityMatrices!.weak_pointers, NrColumns( C ), id );
    
    return id;
    
end );
</pre></div>

<p><a id="X8362669D87FD667B" name="X8362669D87FD667B"></a></p>

<h5>C.4-5 Eval</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Eval</code>( <var class="Arg">LI</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: see below</p>

<p>In case the matrix <var class="Arg">LI</var> was created using <code class="func">LeftInverseLazy</code> (<a href="chap5_mj.html#X7A7E42C179142727"><span class="RefLink">5.5-4</span></a>) then the filter <code class="code">HasEvalLeftInverse</code> for <var class="Arg">LI</var> is set to true and the method listed below will be used to set the attribute <code class="code">Eval</code>. (--&gt; <code class="func">LeftInverse</code> (<a href="chap5_mj.html#X7FBAA11B8008D936"><span class="RefLink">5.5-2</span></a>))</p>


<div class="example"><pre>
InstallMethod( Eval,
        "for homalg matrices",
        [ IsHomalgMatrix and HasEvalLeftInverse ],
        
  function( LI )
    local left_inv;
    
    left_inv := LeftInverse( EvalLeftInverse( LI ) );
    
    if IsBool( left_inv ) then
        return false;
    fi;
    
    return Eval( left_inv );
    
end );
</pre></div>

<p><a id="X84D72DF482F70AD5" name="X84D72DF482F70AD5"></a></p>

<h5>C.4-6 Eval</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Eval</code>( <var class="Arg">RI</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: see below</p>

<p>In case the matrix <var class="Arg">RI</var> was created using <code class="func">RightInverseLazy</code> (<a href="chap5_mj.html#X7FA3E7617EED7E1E"><span class="RefLink">5.5-5</span></a>) then the filter <code class="code">HasEvalRightInverse</code> for <var class="Arg">RI</var> is set to true and the method listed below will be used to set the attribute <code class="code">Eval</code>. (--&gt; <code class="func">RightInverse</code> (<a href="chap5_mj.html#X7AAD17D47839BCAE"><span class="RefLink">5.5-3</span></a>))</p>


<div class="example"><pre>
InstallMethod( Eval,
        "for homalg matrices",
        [ IsHomalgMatrix and HasEvalRightInverse ],
        
  function( RI )
    local right_inv;
    
    right_inv := RightInverse( EvalRightInverse( RI ) );
    
    if IsBool( right_inv ) then
        return false;
    fi;
    
    return Eval( right_inv );
    
end );
</pre></div>

<p><a id="X7928991E8768FA72" name="X7928991E8768FA72"></a></p>

<h5>C.4-7 Eval</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Eval</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the <code class="code">Eval</code> value of a <strong class="pkg">homalg</strong> matrix <var class="Arg">C</var></p>

<p>In case the matrix was created using <code class="func">Involution</code> (<a href="chap5_mj.html#X800FA81F7C42BFEA"><span class="RefLink">5.5-6</span></a>) then the filter <code class="code">HasEvalInvolution</code> for <var class="Arg">C</var> is set to true and the <code class="code">homalgTable</code> function <code class="func">Involution</code> (<a href="chapB_mj.html#X85884C3178473521"><span class="RefLink">B.1-5</span></a>) will be used to set the attribute <code class="code">Eval</code>.</p>


<div class="example"><pre>
InstallMethod( Eval,
        "for homalg matrices (HasEvalInvolution)",
        [ IsHomalgMatrix and HasEvalInvolution ],
        
  function( C )
    local R, RP, M;
    
    R := HomalgRing( C );
    
    RP := homalgTable( R );
    
    M :=  EvalInvolution( C );
    
    if IsBound(RP!.Involution) then
        return RP!.Involution( M );
    fi;
    
    if not IsHomalgInternalMatrixRep( C ) then
        Error( "could not find a procedure called Involution ",
               "in the homalgTable of the non-internal ring\n" );
    fi;
    
    #=====# can only work for homalg internal matrices #=====#
    
    return homalgInternalMatrixHull( TransposedMat( Eval( M )!.matrix ) );
    
end );
</pre></div>

<p><a id="X78D5359480EFC5AC" name="X78D5359480EFC5AC"></a></p>

<h5>C.4-8 Eval</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Eval</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the <code class="code">Eval</code> value of a <strong class="pkg">homalg</strong> matrix <var class="Arg">C</var></p>

<p>In case the matrix was created using <code class="func">TransposedMatrix</code> (<a href="chap5_mj.html#X7D0D35B582D9C0B0"><span class="RefLink">5.5-7</span></a>) then the filter <code class="code">HasEvalTransposedMatrix</code> for <var class="Arg">C</var> is set to true and the <code class="code">homalgTable</code> function <code class="func">TransposedMatrix</code> (<a href="chapB_mj.html#X7AD2EEE680DF472B"><span class="RefLink">B.1-6</span></a>) will be used to set the attribute <code class="code">Eval</code>.</p>


<div class="example"><pre>
InstallMethod( Eval,
        "for homalg matrices (HasEvalTransposedMatrix)",
        [ IsHomalgMatrix and HasEvalTransposedMatrix ],
        
  function( C )
    local R, RP, M;
    
    R := HomalgRing( C );
    
    RP := homalgTable( R );
    
    M :=  EvalTransposedMatrix( C );
    
    if IsBound(RP!.TransposedMatrix) then
        return RP!.TransposedMatrix( M );
    fi;
    
    if not IsHomalgInternalMatrixRep( C ) then
        Error( "could not find a procedure called TransposedMatrix ",
               "in the homalgTable of the non-internal ring\n" );
    fi;
    
    #=====# can only work for homalg internal matrices #=====#
    
    return homalgInternalMatrixHull( TransposedMat( Eval( M )!.matrix ) );
    
end );
</pre></div>

<p><a id="X87BF7FD083D0EE88" name="X87BF7FD083D0EE88"></a></p>

<h5>C.4-9 Eval</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Eval</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the <code class="code">Eval</code> value of a <strong class="pkg">homalg</strong> matrix <var class="Arg">C</var></p>

<p>In case the matrix was created using <code class="func">CoercedMatrix</code> (<a href="chap5_mj.html#X7C4E49D287011DCD"><span class="RefLink">5.2-12</span></a>) then the filter <code class="code">HasEvalCoercedMatrix</code> for <var class="Arg">C</var> is set to true and the <code class="code">Eval</code> value of a copy of <code class="code">EvalCoercedMatrix(</code><var class="Arg">C</var><code class="code">)</code> in <code class="code">HomalgRing(</code><var class="Arg">C</var><code class="code">)</code> will be used to set the attribute <code class="code">Eval</code>.</p>


<div class="example"><pre>
InstallMethod( Eval,
        "for homalg matrices (HasEvalCoercedMatrix)",
        [ IsHomalgMatrix and HasEvalCoercedMatrix ],
        
  function( C )
    local R, RP, m;
    
    R := HomalgRing( C );
    
    RP := homalgTable( R );
    
    m := EvalCoercedMatrix( C );
    
    # delegate to the non-lazy coercening
    return Eval( R * m );
    
end );
</pre></div>

<p><a id="X852DCBD57A742FA5" name="X852DCBD57A742FA5"></a></p>

<h5>C.4-10 Eval</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Eval</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the <code class="code">Eval</code> value of a <strong class="pkg">homalg</strong> matrix <var class="Arg">C</var></p>

<p>In case the matrix was created using <code class="func">CertainRows</code> (<a href="chap5_mj.html#X7CF5CE79796001F6"><span class="RefLink">5.5-8</span></a>) then the filter <code class="code">HasEvalCertainRows</code> for <var class="Arg">C</var> is set to true and the <code class="code">homalgTable</code> function <code class="func">CertainRows</code> (<a href="chapB_mj.html#X7B6FC3267CD9EE9D"><span class="RefLink">B.1-7</span></a>) will be used to set the attribute <code class="code">Eval</code>.</p>


<div class="example"><pre>
InstallMethod( Eval,
        "for homalg matrices (HasEvalCertainRows)",
        [ IsHomalgMatrix and HasEvalCertainRows ],
        
  function( C )
    local R, RP, e, M, plist;
    
    R := HomalgRing( C );
    
    RP := homalgTable( R );
    
    e :=  EvalCertainRows( C );
    
    M := e[1];
    plist := e[2];
    
    ResetFilterObj( C, HasEvalCertainRows );
    
    ## delete the component which was left over by GAP
    Unbind( C!.EvalCertainRows );
    
    if IsBound(RP!.CertainRows) then
        return RP!.CertainRows( M, plist );
    fi;
    
    if not IsHomalgInternalMatrixRep( C ) then
        Error( "could not find a procedure called CertainRows ",
               "in the homalgTable of the non-internal ring\n" );
    fi;
    
    #=====# can only work for homalg internal matrices #=====#
    
    return homalgInternalMatrixHull( Eval( M )!.matrix{ plist } );
    
end );
</pre></div>

<p><a id="X835F6F2E7D590F3D" name="X835F6F2E7D590F3D"></a></p>

<h5>C.4-11 Eval</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Eval</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the <code class="code">Eval</code> value of a <strong class="pkg">homalg</strong> matrix <var class="Arg">C</var></p>

<p>In case the matrix was created using <code class="func">CertainColumns</code> (<a href="chap5_mj.html#X8256AF2A840B19C4"><span class="RefLink">5.5-9</span></a>) then the filter <code class="code">HasEvalCertainColumns</code> for <var class="Arg">C</var> is set to true and the <code class="code">homalgTable</code> function <code class="func">CertainColumns</code> (<a href="chapB_mj.html#X78EADFC67D17CF04"><span class="RefLink">B.1-8</span></a>) will be used to set the attribute <code class="code">Eval</code>.</p>


<div class="example"><pre>
InstallMethod( Eval,
        "for homalg matrices (HasEvalCertainColumns)",
        [ IsHomalgMatrix and HasEvalCertainColumns ],
        
  function( C )
    local R, RP, e, M, plist;
    
    R := HomalgRing( C );
    
    RP := homalgTable( R );
    
    e :=  EvalCertainColumns( C );
    
    M := e[1];
    plist := e[2];
    
    ResetFilterObj( C, HasEvalCertainColumns );
    
    ## delete the component which was left over by GAP
    Unbind( C!.EvalCertainColumns );
    
    if IsBound(RP!.CertainColumns) then
        return RP!.CertainColumns( M, plist );
    fi;
    
    if not IsHomalgInternalMatrixRep( C ) then
        Error( "could not find a procedure called CertainColumns ",
               "in the homalgTable of the non-internal ring\n" );
    fi;
    
    #=====# can only work for homalg internal matrices #=====#
    
    return homalgInternalMatrixHull(
                   Eval( M )!.matrix{[ 1 .. NrRows( M ) ]}{plist} );
    
end );
</pre></div>

<p><a id="X7F35A61C8522A1B0" name="X7F35A61C8522A1B0"></a></p>

<h5>C.4-12 Eval</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Eval</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the <code class="code">Eval</code> value of a <strong class="pkg">homalg</strong> matrix <var class="Arg">C</var></p>

<p>In case the matrix was created using <code class="func">UnionOfRows</code> (<a href="chap5_mj.html#X7D6D0BDF854C9EBC"><span class="RefLink">5.5-10</span></a>) then the filter <code class="code">HasEvalUnionOfRows</code> for <var class="Arg">C</var> is set to true and the <code class="code">homalgTable</code> function <code class="func">UnionOfRows</code> (<a href="chapB_mj.html#X7DEB535782A3323E"><span class="RefLink">B.1-9</span></a>) or the <code class="code">homalgTable</code> function <code class="func">UnionOfRowsPair</code> (<a href="chapB_mj.html#X86C345CE82AAB220"><span class="RefLink">B.1-10</span></a>) will be used to set the attribute <code class="code">Eval</code>.</p>


<div class="example"><pre>
InstallMethod( Eval,
        "for homalg matrices (HasEvalUnionOfRows)",
        [ IsHomalgMatrix and HasEvalUnionOfRows ],
        
  function( C )
    local R, RP, e, i, combine;
    
    R := HomalgRing( C );
    
    RP := homalgTable( R );
    
    # Make it mutable
    e := ShallowCopy( EvalUnionOfRows( C ) );
    
    # In case of nested UnionOfRows, we try to avoid
    # recursion, since the gap stack is rather small
    # additionally unpack PreEvals
    i := 1;
    while i &lt;= Length( e ) do
        
        if HasPreEval( e[i] ) and not HasEval( e[i] ) then
            
            e[i] := PreEval( e[i] );
            
        elif HasEvalUnionOfRows( e[i] ) and not HasEval( e[i] ) then
            
            e := Concatenation( e{[ 1 .. (i-1) ]}, EvalUnionOfRows( e[i] ), e{[ (i+1) .. Length( e ) ]}  );
            
        else
            
            i := i + 1;
            
        fi;
        
    od;
    
    # Combine zero matrices
    i := 1;
    while i + 1 &lt;= Length( e ) do
        
        if HasIsZero( e[i] ) and IsZero( e[i] ) and HasIsZero( e[i+1] ) and IsZero( e[i+1] ) then
            
            e[i] := HomalgZeroMatrix( NrRows( e[i] ) + NrRows( e[i+1] ), NrColumns( e[i] ), HomalgRing( e[i] ) );
            
            Remove( e, i + 1 );
            
        else
            
            i := i + 1;
            
        fi;
        
    od;
    
    # After combining zero matrices only a single one might be left
    if Length( e ) = 1 then
        
        return e[1];
        
    fi;
    
    # Use RP!.UnionOfRows if available
    if IsBound(RP!.UnionOfRows) then
        
        return RP!.UnionOfRows( e );
        
    fi;
    
    # Fall back to RP!.UnionOfRowsPair or manual fallback for internal matrices
    # Combine the matrices
    # Use a balanced binary tree to keep the sizes small (heuristically)
    # to avoid a huge memory footprint
    
    if not IsBound(RP!.UnionOfRowsPair) and not IsHomalgInternalMatrixRep( C ) then
        Error( "could neither find a procedure called UnionOfRows ",
               "nor a procedure called UnionOfRowsPair ",
               "in the homalgTable of the non-internal ring\n" );
    fi;
    
    combine := function( A, B )
      local result, U;
        
        if IsBound(RP!.UnionOfRowsPair) then
            
            result := RP!.UnionOfRowsPair( A, B );
            
        else
            
            #=====# can only work for homalg internal matrices #=====#
            
            U := ShallowCopy( Eval( A )!.matrix );
            
            U{ [ NrRows( A ) + 1 .. NrRows( A ) + NrRows( B ) ] } := Eval( B )!.matrix;
            
            result := homalgInternalMatrixHull( U );
            
        fi;
        
        return HomalgMatrixWithAttributes( [
                    Eval, result,
                    EvalUnionOfRows, [ A, B ],
                    NrRows, NrRows( A ) + NrRows( B ),
                    NrColumns, NrColumns( A ),
                    ], R );
        
    end;
    
    while Length( e ) &gt; 1 do
        
        for i in [ 1 .. Int( Length( e ) / 2 ) ] do
            
            e[ 2 * i - 1 ] := combine( e[ 2 * i - 1 ], e[ 2 * i ] );
            Unbind( e[ 2 * i ] );
            
        od;
        
        e := Compacted( e );
        
    od;
    
    return Eval( e[1] );
    
end );
</pre></div>

<p><a id="X7EDE6095820F8128" name="X7EDE6095820F8128"></a></p>

<h5>C.4-13 Eval</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Eval</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the <code class="code">Eval</code> value of a <strong class="pkg">homalg</strong> matrix <var class="Arg">C</var></p>

<p>In case the matrix was created using <code class="func">UnionOfColumns</code> (<a href="chap5_mj.html#X7FF9661D85EC46B1"><span class="RefLink">5.5-11</span></a>) then the filter <code class="code">HasEvalUnionOfColumns</code> for <var class="Arg">C</var> is set to true and the <code class="code">homalgTable</code> function <code class="func">UnionOfColumns</code> (<a href="chapB_mj.html#X7DF5DB55836D13A7"><span class="RefLink">B.1-11</span></a>) or the <code class="code">homalgTable</code> function <code class="func">UnionOfColumnsPair</code> (<a href="chapB_mj.html#X8092789C87E37020"><span class="RefLink">B.1-12</span></a>) will be used to set the attribute <code class="code">Eval</code>.</p>


<div class="example"><pre>
InstallMethod( Eval,
        "for homalg matrices (HasEvalUnionOfColumns)",
        [ IsHomalgMatrix and HasEvalUnionOfColumns ],
        
  function( C )
    local R, RP, e, i, combine;
    
    R := HomalgRing( C );
    
    RP := homalgTable( R );
    
    # Make it mutable
    e := ShallowCopy( EvalUnionOfColumns( C ) );
    
    # In case of nested UnionOfColumns, we try to avoid
    # recursion, since the gap stack is rather small
    # additionally unpack PreEvals
    i := 1;
    while i &lt;= Length( e ) do
        
        if HasPreEval( e[i] ) and not HasEval( e[i] ) then
            
            e[i] := PreEval( e[i] );
            
        elif HasEvalUnionOfColumns( e[i] ) and not HasEval( e[i] ) then
            
            e := Concatenation( e{[ 1 .. (i-1) ]}, EvalUnionOfColumns( e[i] ), e{[ (i+1) .. Length( e ) ]}  );
            
        else
            
            i := i + 1;
            
        fi;
        
    od;
    
    # Combine zero matrices
    i := 1;
    while i + 1 &lt;= Length( e ) do
        
        if HasIsZero( e[i] ) and IsZero( e[i] ) and HasIsZero( e[i+1] ) and IsZero( e[i+1] ) then
            
            e[i] := HomalgZeroMatrix( NrRows( e[i] ), NrColumns( e[i] ) + NrColumns( e[i+1] ), HomalgRing( e[i] ) );
            
            Remove( e, i + 1 );
            
        else
            
            i := i + 1;
            
        fi;
        
    od;
    
    # After combining zero matrices only a single one might be left
    if Length( e ) = 1 then
        
        return e[1];
        
    fi;
    
    # Use RP!.UnionOfColumns if available
    if IsBound(RP!.UnionOfColumns) then
        
        return RP!.UnionOfColumns( e );
        
    fi;
    
    # Fall back to RP!.UnionOfColumnsPair or manual fallback for internal matrices
    # Combine the matrices
    # Use a balanced binary tree to keep the sizes small (heuristically)
    # to avoid a huge memory footprint
    
    if not IsBound(RP!.UnionOfColumnsPair) and not IsHomalgInternalMatrixRep( C ) then
        Error( "could neither find a procedure called UnionOfColumns ",
               "nor a procedure called UnionOfColumnsPair ",
               "in the homalgTable of the non-internal ring\n" );
    fi;
    
    combine := function( A, B )
      local result, U;
        
        if IsBound(RP!.UnionOfColumnsPair) then
            
            result := RP!.UnionOfColumnsPair( A, B );
            
        else
            
            #=====# can only work for homalg internal matrices #=====#
            
            U := List( Eval( A )!.matrix, ShallowCopy );
            
            U{ [ 1 .. NrRows( A ) ] }
              { [ NrColumns( A ) + 1 .. NrColumns( A ) + NrColumns( B ) ] }
              := Eval( B )!.matrix;
            
            result := homalgInternalMatrixHull( U );
            
        fi;
        
        return HomalgMatrixWithAttributes( [
                    Eval, result,
                    EvalUnionOfColumns, [ A, B ],
                    NrRows, NrRows( A ),
                    NrColumns, NrColumns( A ) + NrColumns( B )
                    ], R );
        
    end;
    
    while Length( e ) &gt; 1 do
        
        for i in [ 1 .. Int( Length( e ) / 2 ) ] do
            
            e[ 2 * i - 1 ] := combine( e[ 2 * i - 1 ], e[ 2 * i ] );
            Unbind( e[ 2 * i ] );
            
        od;
        
        e := Compacted( e );
        
    od;
    
    return Eval( e[1] );
    
end );
</pre></div>

<p><a id="X7FD68F43831046B6" name="X7FD68F43831046B6"></a></p>

<h5>C.4-14 Eval</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Eval</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the <code class="code">Eval</code> value of a <strong class="pkg">homalg</strong> matrix <var class="Arg">C</var></p>

<p>In case the matrix was created using <code class="func">DiagMat</code> (<a href="chap5_mj.html#X7C7830BE847D84B4"><span class="RefLink">5.5-16</span></a>) then the filter <code class="code">HasEvalDiagMat</code> for <var class="Arg">C</var> is set to true and the <code class="code">homalgTable</code> function <code class="func">DiagMat</code> (<a href="chapB_mj.html#X86C5B86981FA1F9A"><span class="RefLink">B.1-13</span></a>) will be used to set the attribute <code class="code">Eval</code>.</p>


<div class="example"><pre>
InstallMethod( Eval,
        "for homalg matrices (HasEvalDiagMat)",
        [ IsHomalgMatrix and HasEvalDiagMat ],
        
  function( C )
    local R, RP, e, l, z, m, n, diag, mat;
    
    R := HomalgRing( C );
    
    RP := homalgTable( R );
    
    e :=  EvalDiagMat( C );
    
    if IsBound(RP!.DiagMat) then
        return RP!.DiagMat( e );
    fi;
    
    l := Length( e );
    
    if not IsHomalgInternalMatrixRep( C ) then
        return UnionOfRows(
                       List( [ 1 .. l ],
                             i -&gt; UnionOfColumns(
                                     List( [ 1 .. l ],
                                           function( j )
                                             if i = j then
                                                 return e[i];
                                             fi;
                                             return HomalgZeroMatrix( NrRows( e[i] ), NrColumns( e[j] ), R );
                                           end )
                                     )
                             )
                       );
    fi;
    
    #=====# can only work for homalg internal matrices #=====#
    
    z := Zero( R );
    
    m := Sum( List( e, NrRows ) );
    n := Sum( List( e, NrColumns ) );
    
    diag := List( [ 1 .. m ], a -&gt; List( [ 1 .. n ], b -&gt; z ) );
    
    m := 0;
    n := 0;
    
    for mat in e do
        diag{ [ m + 1 .. m + NrRows( mat ) ] }{ [ n + 1 .. n + NrColumns( mat ) ] }
          := Eval( mat )!.matrix;
        
        m := m + NrRows( mat );
        n := n + NrColumns( mat );
    od;
    
    return homalgInternalMatrixHull( diag );
    
end );
</pre></div>

<p><a id="X84F45FB4854A079C" name="X84F45FB4854A079C"></a></p>

<h5>C.4-15 Eval</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Eval</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the <code class="code">Eval</code> value of a <strong class="pkg">homalg</strong> matrix <var class="Arg">C</var></p>

<p>In case the matrix was created using <code class="func">KroneckerMat</code> (<a href="chap5_mj.html#X7CDA5D848468A0AA"><span class="RefLink">5.5-17</span></a>) then the filter <code class="code">HasEvalKroneckerMat</code> for <var class="Arg">C</var> is set to true and the <code class="code">homalgTable</code> function <code class="func">KroneckerMat</code> (<a href="chapB_mj.html#X82202A6A7FAB7174"><span class="RefLink">B.1-14</span></a>) will be used to set the attribute <code class="code">Eval</code>.</p>


<div class="example"><pre>
InstallMethod( Eval,
        "for homalg matrices (HasEvalKroneckerMat)",
        [ IsHomalgMatrix and HasEvalKroneckerMat ],
        
  function( C )
    local R, RP, A, B;
    
    R := HomalgRing( C );
    
    if ( HasIsCommutative( R ) and not IsCommutative( R ) ) and
       ( HasIsSuperCommutative( R ) and not IsSuperCommutative( R ) ) then
        Info( InfoWarning, 1, "\033[01m\033[5;31;47m",
              "the Kronecker product is only defined for (super) commutative rings!",
              "\033[0m" );
    fi;
    
    RP := homalgTable( R );
    
    A :=  EvalKroneckerMat( C )[1];
    B :=  EvalKroneckerMat( C )[2];
    
    if IsBound(RP!.KroneckerMat) then
        return RP!.KroneckerMat( A, B );
    fi;
    
    if not IsHomalgInternalMatrixRep( C ) then
        Error( "could not find a procedure called KroneckerMat ",
               "in the homalgTable of the non-internal ring\n" );
    fi;
    
    #=====# can only work for homalg internal matrices #=====#
    
    return homalgInternalMatrixHull(
                   KroneckerProduct( Eval( A )!.matrix, Eval( B )!.matrix ) );
    ## this was easy, thanks GAP :)
    
end );
</pre></div>

<p><a id="X78ADE5C879583E7B" name="X78ADE5C879583E7B"></a></p>

<h5>C.4-16 Eval</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Eval</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the <code class="code">Eval</code> value of a <strong class="pkg">homalg</strong> matrix <var class="Arg">C</var></p>

<p>In case the matrix was created using <code class="func">DualKroneckerMat</code> (<a href="chap5_mj.html#X7ECF744B7DE82BED"><span class="RefLink">5.5-18</span></a>) then the filter <code class="code">HasEvalDualKroneckerMat</code> for <var class="Arg">C</var> is set to true and the <code class="code">homalgTable</code> function <code class="func">DualKroneckerMat</code> (<a href="chapB_mj.html#X87E0747D7FEEAC76"><span class="RefLink">B.1-15</span></a>) will be used to set the attribute <code class="code">Eval</code>.</p>


<div class="example"><pre>
InstallMethod( Eval,
        "for homalg matrices (HasEvalDualKroneckerMat)",
        [ IsHomalgMatrix and HasEvalDualKroneckerMat ],
        
  function( C )
    local R, RP, A, B;
    
    R := HomalgRing( C );
    
    if ( HasIsCommutative( R ) and not IsCommutative( R ) ) and
       ( HasIsSuperCommutative( R ) and not IsSuperCommutative( R ) ) then
        Info( InfoWarning, 1, "\033[01m\033[5;31;47m",
              "the dual Kronecker product is only defined for (super) commutative rings!",
              "\033[0m" );
    fi;
    
    RP := homalgTable( R );
    
    A :=  EvalDualKroneckerMat( C )[1];
    B :=  EvalDualKroneckerMat( C )[2];
    
    # work around errors in Singular when taking the opposite ring of a ring with ordering lp
    # https://github.com/Singular/Singular/issues/1011
    # fixed in version 4.2.0
    if IsBound(RP!.DualKroneckerMat) and not (
        IsBound( R!.ring ) and
        IsBound( R!.ring!.stream ) and
        IsBound( R!.ring!.stream.cas ) and R!.ring!.stream.cas = "singular" and
        ( not IsBound( R!.ring!.stream.version ) or R!.ring!.stream.version &lt; 4200 ) and
        IsBound( R!.order ) and IsString( R!.order ) and StartsWith( R!.order, "lex" )
    ) then
        
        return RP!.DualKroneckerMat( A, B );
        
    fi;
    
    if HasIsCommutative( R ) and IsCommutative( R ) then
        
        return Eval( KroneckerMat( B, A ) );
        
    else
        
        return Eval(
            TransposedMatrix( Involution(
                KroneckerMat( TransposedMatrix( Involution( B ) ), TransposedMatrix( Involution( A ) ) )
            ) )
        );
        
    fi;
    
end );
</pre></div>

<p><a id="X7B68797C7EA79B10" name="X7B68797C7EA79B10"></a></p>

<h5>C.4-17 Eval</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Eval</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the <code class="code">Eval</code> value of a <strong class="pkg">homalg</strong> matrix <var class="Arg">C</var></p>

<p>In case the matrix was created using <code class="func">\*</code> (<a href="chap5_mj.html#X7D1A074278B415BE"><span class="RefLink">5.5-19</span></a>) then the filter <code class="code">HasEvalMulMat</code> for <var class="Arg">C</var> is set to true and the <code class="code">homalgTable</code> function <code class="func">MulMat</code> (<a href="chapB_mj.html#X828F8C7785EEC3D1"><span class="RefLink">B.1-16</span></a>) will be used to set the attribute <code class="code">Eval</code>.</p>


<div class="example"><pre>
InstallMethod( Eval,
        "for homalg matrices (HasEvalMulMat)",
        [ IsHomalgMatrix and HasEvalMulMat ],
        
  function( C )
    local R, RP, e, a, A;
    
    R := HomalgRing( C );
    
    RP := homalgTable( R );
    
    e :=  EvalMulMat( C );
    
    a := e[1];
    A := e[2];
    
    if IsBound(RP!.MulMat) then
        return RP!.MulMat( a, A );
    fi;
    
    if not IsHomalgInternalMatrixRep( C ) then
        Error( "could not find a procedure called MulMat ",
               "in the homalgTable of the non-internal ring\n" );
    fi;
    
    #=====# can only work for homalg internal matrices #=====#
    
    return a * Eval( A );
    
end );

InstallMethod( Eval,
        "for homalg matrices (HasEvalMulMatRight)",
        [ IsHomalgMatrix and HasEvalMulMatRight ],
        
  function( C )
    local R, RP, e, A, a;
    
    R := HomalgRing( C );
    
    RP := homalgTable( R );
    
    e :=  EvalMulMatRight( C );
    
    A := e[1];
    a := e[2];
    
    if IsBound(RP!.MulMatRight) then
        return RP!.MulMatRight( A, a );
    fi;
    
    if not IsHomalgInternalMatrixRep( C ) then
        Error( "could not find a procedure called MulMatRight ",
               "in the homalgTable of the non-internal ring\n" );
    fi;
    
    #=====# can only work for homalg internal matrices #=====#
    
    return Eval( A ) * a;
    
end );
</pre></div>

<p><a id="X85971C16868BD83C" name="X85971C16868BD83C"></a></p>

<h5>C.4-18 Eval</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Eval</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the <code class="code">Eval</code> value of a <strong class="pkg">homalg</strong> matrix <var class="Arg">C</var></p>

<p>In case the matrix was created using <code class="func">\+</code> (<a href="chap5_mj.html#X87C773DA85B21ADF"><span class="RefLink">5.5-20</span></a>) then the filter <code class="code">HasEvalAddMat</code> for <var class="Arg">C</var> is set to true and the <code class="code">homalgTable</code> function <code class="func">AddMat</code> (<a href="chapB_mj.html#X7B0B12F080A90039"><span class="RefLink">B.1-17</span></a>) will be used to set the attribute <code class="code">Eval</code>.</p>


<div class="example"><pre>
InstallMethod( Eval,
        "for homalg matrices (HasEvalAddMat)",
        [ IsHomalgMatrix and HasEvalAddMat ],
        
  function( C )
    local R, RP, e, A, B;
    
    R := HomalgRing( C );
    
    RP := homalgTable( R );
    
    e :=  EvalAddMat( C );
    
    A := e[1];
    B := e[2];
    
    ResetFilterObj( C, HasEvalAddMat );
    
    ## delete the component which was left over by GAP
    Unbind( C!.EvalAddMat );
    
    if IsBound(RP!.AddMat) then
        return RP!.AddMat( A, B );
    fi;
    
    if not IsHomalgInternalMatrixRep( C ) then
        Error( "could not find a procedure called AddMat ",
               "in the homalgTable of the non-internal ring\n" );
    fi;
    
    #=====# can only work for homalg internal matrices #=====#
    
    return Eval( A ) + Eval( B );
    
end );
</pre></div>

<p><a id="X86F848318791595C" name="X86F848318791595C"></a></p>

<h5>C.4-19 Eval</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Eval</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the <code class="code">Eval</code> value of a <strong class="pkg">homalg</strong> matrix <var class="Arg">C</var></p>

<p>In case the matrix was created using <code class="func">\-</code> (<a href="chap5_mj.html#X784B57617B24208C"><span class="RefLink">5.5-21</span></a>) then the filter <code class="code">HasEvalSubMat</code> for <var class="Arg">C</var> is set to true and the <code class="code">homalgTable</code> function <code class="func">SubMat</code> (<a href="chapB_mj.html#X7FE11AA27AE7D2D7"><span class="RefLink">B.1-18</span></a>) will be used to set the attribute <code class="code">Eval</code>.</p>


<div class="example"><pre>
InstallMethod( Eval,
        "for homalg matrices (HasEvalSubMat)",
        [ IsHomalgMatrix and HasEvalSubMat ],
        
  function( C )
    local R, RP, e, A, B;
    
    R := HomalgRing( C );
    
    RP := homalgTable( R );
    
    e :=  EvalSubMat( C );
    
    A := e[1];
    B := e[2];
    
    ResetFilterObj( C, HasEvalSubMat );
    
    ## delete the component which was left over by GAP
    Unbind( C!.EvalSubMat );
    
    if IsBound(RP!.SubMat) then
        return RP!.SubMat( A, B );
    fi;
    
    if not IsHomalgInternalMatrixRep( C ) then
        Error( "could not find a procedure called SubMat ",
               "in the homalgTable of the non-internal ring\n" );
    fi;
    
    #=====# can only work for homalg internal matrices #=====#
    
    return Eval( A ) - Eval( B );
    
end );
</pre></div>

<p><a id="X7F7682FC86F602C2" name="X7F7682FC86F602C2"></a></p>

<h5>C.4-20 Eval</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Eval</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the <code class="code">Eval</code> value of a <strong class="pkg">homalg</strong> matrix <var class="Arg">C</var></p>

<p>In case the matrix was created using <code class="func">\*</code> (<a href="chap5_mj.html#X7F5961D78754157B"><span class="RefLink">5.5-22</span></a>) then the filter <code class="code">HasEvalCompose</code> for <var class="Arg">C</var> is set to true and the <code class="code">homalgTable</code> function <code class="func">Compose</code> (<a href="chapB_mj.html#X7D491D957E63C3A4"><span class="RefLink">B.1-19</span></a>) will be used to set the attribute <code class="code">Eval</code>.</p>


<div class="example"><pre>
InstallMethod( Eval,
        "for homalg matrices (HasEvalCompose)",
        [ IsHomalgMatrix and HasEvalCompose ],
        
  function( C )
    local R, RP, e, A, B;
    
    R := HomalgRing( C );
    
    RP := homalgTable( R );
    
    e :=  EvalCompose( C );
    
    A := e[1];
    B := e[2];
    
    ResetFilterObj( C, HasEvalCompose );
    
    ## delete the component which was left over by GAP
    Unbind( C!.EvalCompose );
    
    if IsBound(RP!.Compose) then
        return RP!.Compose( A, B );
    fi;
    
    if not IsHomalgInternalMatrixRep( C ) then
        Error( "could not find a procedure called Compose ",
               "in the homalgTable of the non-internal ring\n" );
    fi;
    
    #=====# can only work for homalg internal matrices #=====#
    
    return Eval( A ) * Eval( B );
    
end );
</pre></div>

<p><a id="X848FE4F07BAF89DB" name="X848FE4F07BAF89DB"></a></p>

<h5>C.4-21 Eval</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Eval</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns: the <code class="code">Eval</code> value of a <strong class="pkg">homalg</strong> matrix <var class="Arg">C</var></p>

<p>In case the matrix was created using <code class="func">CoefficientsWithGivenMonomials</code> (<a href="chap5_mj.html#X7EEFD7887E96714F"><span class="RefLink">5.5-60</span></a>) then the filter <code class="code">HasEvalCoefficientsWithGivenMonomials</code> for <var class="Arg">C</var> is set to true and the <code class="code">homalgTable</code> function <code class="func">CoefficientsWithGivenMonomials</code> (<a href="chapB_mj.html#X8450E904787CBD35"><span class="RefLink">B.1-24</span></a>) will be used to set the attribute <code class="code">Eval</code>.</p>


<div class="example"><pre>
InstallMethod( Eval,
        "for homalg matrices (HasEvalCoefficientsWithGivenMonomials)",
        [ IsHomalgMatrix and HasEvalCoefficientsWithGivenMonomials ],
        
  function( C )
    local R, RP, pair, M, monomials;
    
    R := HomalgRing( C );
    
    RP := homalgTable( R );

    pair := EvalCoefficientsWithGivenMonomials( C );

    M := pair[1];
    monomials := pair[2];
    
    if IsBound( RP!.CoefficientsWithGivenMonomials ) then
        
        return RP!.CoefficientsWithGivenMonomials( M, monomials );
        
    fi;

    Error( "could not find a procedure called CoefficientsWithGivenMonomials ",
            "in the homalgTable of the ring\n" );
    
end );
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chapB_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapD_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chapA_mj.html">A</a>  <a href="chapB_mj.html">B</a>  <a href="chapC_mj.html">C</a>  <a href="chapD_mj.html">D</a>  <a href="chapE_mj.html">E</a>  <a href="chapF_mj.html">F</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
