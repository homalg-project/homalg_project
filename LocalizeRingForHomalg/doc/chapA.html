<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (LocalizeRingForHomalg) - Appendix A: Overview of the LocalizeRingForHomalg Package Source Code</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chapA"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chapA.html">A</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap5.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chapA_mj.html">[MathJax on]</a></p>
<p><a id="X7C7697867CBF79C9" name="X7C7697867CBF79C9"></a></p>
<div class="ChapSects"><a href="chapA.html#X7C7697867CBF79C9">A <span class="Heading">Overview of the <strong class="pkg">LocalizeRingForHomalg</strong> Package Source Code</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapA.html#X87807E467C364A00">A.1 <span class="Heading">The generic Methods</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapA.html#X7B04DAB47BAB9165">A.1-1 BasisOfRowModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapA.html#X8196F11E7FD3201C">A.1-2 DecideZeroRows</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapA.html#X7B1B3662863726EE">A.1-3 SyzygiesGeneratorsOfRows</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapA.html#X85822F1B7E006A87">A.2 <span class="Heading">The Local Decide Zero trick</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chapA.html#X790256E88417752F">A.2-1 DecideZeroRows</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chapA.html#X8508AEF8845565A1">A.3 <span class="Heading">Tools</span></a>
</span>
</div>
</div>

<h3>A <span class="Heading">Overview of the <strong class="pkg">LocalizeRingForHomalg</strong> Package Source Code</span></h3>

<p>This appendix is included in the documentation to shine some light on the mathematical backgrounds of this Package. Neither is it needed to work with this package nor should the methods presented here be called directly. The functions documented here are entries of the so called ring table and not to be called directly. There are higher level methods in declared and installed in <strong class="pkg">MatricesForHomalg</strong>, which call this functions (--&gt; <code class="code">?MatricesForHomalg:The Basic Matrix Operations</code>).</p>

<p>We only present the simpler procedures, where no transformation matrices are computed, since the computation of transformation matrices carries no further mathematical ideas.</p>

<p><a id="X87807E467C364A00" name="X87807E467C364A00"></a></p>

<h4>A.1 <span class="Heading">The generic Methods</span></h4>

<p>There are some methods in localized rings, where homalg is able to fall back on procedures of the corresponding global ring. Furthermore these methods work quite good together with Mora's algorithm as implemented in Singular, since we can treat it like a global ring. We will present some methods as an example, to show the idea:</p>

<p><a id="X7B04DAB47BAB9165" name="X7B04DAB47BAB9165"></a></p>

<h5>A.1-1 BasisOfRowModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BasisOfRowModule</code>( <var class="Arg">M</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: a "basis" of the module generated by M</p>

<p>This procedure computes a basis by using the Funcod of the underlying computation ring. If the computation ring is given by Mora's Algorithm, we will indeed compute a local basis. If we just use the global ring for computations, this will be a global basis and is just computed for some simplifications and not for the use of reducing by it. Of course we can just forget about the denominator of <var class="Arg">M</var>.</p>


<div class="example"><pre>
BasisOfRowModule :=
  function( M )

    Info(
      InfoLocalizeRingForHomalg,
      2,
      "Start BasisOfRowModule with ",
      NrRows( M ), "x", NrColumns( M )
    );

    return HomalgLocalMatrix( BasisOfRowModule( Numerator( M ) ), HomalgRing( M ) );
    
end,
</pre></div>

<p><a id="X8196F11E7FD3201C" name="X8196F11E7FD3201C"></a></p>

<h5>A.1-2 DecideZeroRows</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DecideZeroRows</code>( <var class="Arg">A</var>, <var class="Arg">B</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: a "reduced" form of <var class="Arg">A</var> with respect to <var class="Arg">B</var></p>

<p>This procedure just calls the DecideZeroRows of the computation ring for the numerator of <var class="Arg">A</var>.</p>

<p>If we use Mora's algorithm this procedure will just call it. The result is divided by the denominator of <var class="Arg">A</var> afterwards. Again we do not need to care about the denominator of B.</p>

<p>If we use the reduction implemented in this package, this Funcod is overwritten and will not be called.</p>


<div class="example"><pre>
DecideZeroRows :=
  function( A, B )
    local R, ComputationRing, hook, result;
    
    Info(
      InfoLocalizeRingForHomalg,
      2,
      "Start DecideZeroRows with ",
      NrRows( A ), "x", NrColumns( A ),
      " and ",
      NrRows( B ), "x", NrColumns( B )
    );
    
    R := HomalgRing( A );
    ComputationRing := AssociatedComputationRing( R );
    
    result := DecideZeroRows( Numerator( A ) , Numerator( B ) );
    result := HomalgLocalMatrix( result, Denominator( A ) , R );
    Info( InfoLocalizeRingForHomalgShowUnits, 1, "DecideZeroRows: produces denominator: ", Name( Denominator( result ) ) );
    return result;

  end,
</pre></div>

<p><a id="X7B1B3662863726EE" name="X7B1B3662863726EE"></a></p>

<h5>A.1-3 SyzygiesGeneratorsOfRows</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SyzygiesGeneratorsOfRows</code>( <var class="Arg">M</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: a "basis" of the syzygies of the arguments (for details consult the homalg help)</p>

<p>It is easy to see, that a global syzygy is also a local syzygy and vice versa when clearing the local Syzygy of its denominators. So this procedure just calls the syzygy Funcod of the underlying computation ring.</p>


<div class="example"><pre>
SyzygiesGeneratorsOfRows :=
  function( M )
    
    Info(
      InfoLocalizeRingForHomalg,
      2,
      "Start SyzygiesGeneratorsOfRows with ",
      NrRows( M ), "x", NrColumns( M )
    );

    return HomalgLocalMatrix(\
             SyzygiesGeneratorsOfRows( Numerator( M ) ), HomalgRing( M )\
           );
    
  end,
</pre></div>

<p><a id="X85822F1B7E006A87" name="X85822F1B7E006A87"></a></p>

<h4>A.2 <span class="Heading">The Local Decide Zero trick</span></h4>

<p><a id="X790256E88417752F" name="X790256E88417752F"></a></p>

<h5>A.2-1 DecideZeroRows</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DecideZeroRows</code>( <var class="Arg">B</var>, <var class="Arg">A</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: a "reduced" form of <var class="Arg">B</var> with respect to <var class="Arg">A</var></p>

<p>This procedure is the mathematical core procedure of this package. We use a trick to decide locally, whether <var class="Arg">B</var> can be reduced to zero by <var class="Arg">A</var> with a global computation. First a heuristic is used by just checking, whether the element lies inside the global module, generated by the generators of the local module. This of course implies this for the local module having the advantage of a short computation time and leaving a normal form free of denominators. If this check fails, we use our trick to check for each row of <var class="Arg">B</var> independently, whether it lies in the module generated by <var class="Arg">B</var>.</p>


<div class="example"><pre>
DecideZeroRows :=
  function( B, A )
    local R, T, m, gens, n, GlobalR, one, N, b, numB, denB, i, B1, A1, B2, A2, B3;
    
    Info( 
       InfoLocalizeRingForHomalg,
       2,
       "Start DecideZeroRows with ",
       NrRows( B ), "x", NrColumns( B ),
       " and ",
       NrRows( A ), "x", NrColumns( A ) 
    );
    
    R := HomalgRing( B );
    GlobalR := AssociatedComputationRing( R );
    T := HomalgVoidMatrix( R );
    gens := GeneratorsOfMaximalLeftIdeal( R );
    n := NrRows( gens );
    one := One( GlobalR );
    
    m := NrRows( A );
    A1 := Numerator( A );
    
    N := HomalgZeroMatrix( 0, NrColumns( B ), R );
    b := Eval( B );
    numB := b[1];
    denB := b[2];
    
    for i in [ 1 .. NrRows( B ) ] do
    
        #use global reduction as heuristic
        B1 := CertainRows( numB, [ i ] );
        B2 := HomalgLocalMatrix( DecideZeroRows( B1, A1 ), R );
        
        #if it is nonzero, check whether local reduction makes it zero
        if not IsZero( B2 ) then
          A2 := UnionOfRows( A1, gens * B1 );
          A2 := BasisOfRows( A2 );
          B3 := HomalgLocalMatrix( DecideZeroRows( B1, A2 ), R );
          if IsZero( B3 ) then
            B2 := B3;
          fi;
        fi;
        
        N := UnionOfRows( N, B2 );
        
    od;
    
    N := HomalgRingElement( one, denB, R ) * N;
    
    Info( InfoLocalizeRingForHomalgShowUnits, 1, "DecideZeroRows: produces denominator: ", Name( Denominator( N ) ) );
    
    return N;
    
  end,
</pre></div>

<p><a id="X8508AEF8845565A1" name="X8508AEF8845565A1"></a></p>

<h4>A.3 <span class="Heading">Tools</span></h4>

<p>The package <strong class="pkg">LocalizeRingForHomalg</strong> also implements tool functions. These are referred to from <strong class="pkg">MatricesForHomalg</strong> automatically. We list the implemented methods here are and refer to the <strong class="pkg">MatricesForHomalg</strong> documentation (--&gt; <code class="code">?MatricesForHomalg: The Matrix Tool Operations</code> and <code class="code">?MatricesForHomalg:RingElement</code>) for details. All tools functions from <strong class="pkg">MatricesForHomalg</strong> not listed here are also supported by fallback tools.</p>


<ul>
<li><p>IsZero</p>

</li>
<li><p>IsOne</p>

</li>
<li><p>Minus</p>

</li>
<li><p>DivideByUnit</p>

</li>
<li><p>IsUnit</p>

</li>
<li><p>Sum</p>

</li>
<li><p>Product</p>

</li>
<li><p>ShallowCopy</p>

</li>
<li><p>ZeroMatrix</p>

</li>
<li><p>IdentityMatrix</p>

</li>
<li><p>AreEqualMatrices</p>

</li>
<li><p>Involution</p>

</li>
<li><p>CertainRows</p>

</li>
<li><p>CertainColumns</p>

</li>
<li><p>UnionOfRows</p>

</li>
<li><p>UnionOfColumns</p>

</li>
<li><p>DiagMat</p>

</li>
<li><p>KroneckerMat</p>

</li>
<li><p>MulMat</p>

</li>
<li><p>AddMat</p>

</li>
<li><p>SubMat</p>

</li>
<li><p>Compose</p>

</li>
<li><p>NrRows</p>

</li>
<li><p>NrColumns</p>

</li>
<li><p>IsZeroMatrix</p>

</li>
<li><p>IsDiagonalMatrix</p>

</li>
<li><p>ZeroRows</p>

</li>
<li><p>ZeroColumns</p>

</li>
</ul>

<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap5.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chapA.html">A</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
